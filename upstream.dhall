{- Generated by ds-to-dhall DO NOT EDIT -}

let Kubernetes =
      https://raw.githubusercontent.com/dhall-lang/dhall-kubernetes/f4bf4b9ddf669f7149ec32150863a93d6c4b3ef1/1.18/schemas.dhall sha256:f2b22e8d2400d7698bc05e47d9e945b4d795e3290b114a20657ef93c0e9557ce

in  { Base =
      { Service.backend = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue =
                  "Dummy service that prevents backend pods from being scheduled on the same node if possible."
              }
            ]
          , labels = Some
            [ { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "group", mapValue = "backend" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "backend"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , clusterIP = Some "None"
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "unused"
              , port = 10811
              , targetPort = Some (< Int : Natural | String : Text >.Int 10811)
              }
            ]
          , selector = Some [ { mapKey = "group", mapValue = "backend" } ]
          , type = Some "ClusterIP"
          }
        }
      , StorageClass.sourcegraph = Kubernetes.StorageClass::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some [ { mapKey = "deploy", mapValue = "sourcegraph" } ]
          , name = Some "sourcegraph"
          }
        , parameters = Some [ { mapKey = "type", mapValue = "pd-ssd" } ]
        , provisioner = "kubernetes.io/gce-pd"
        , reclaimPolicy = Some "Retain"
        }
      }
    , Cadvisor =
      { ClusterRole.cadvisor = Kubernetes.ClusterRole::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app", mapValue = "cadvisor" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "cadvisor" }
            , { mapKey = "category", mapValue = "rbac" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "cluster-admin"
              }
            ]
          , name = Some "cadvisor"
          }
        , rules = Some
          [ Kubernetes.PolicyRule::{
            , apiGroups = Some [ "policy" ]
            , resourceNames = Some [ "cadvisor" ]
            , resources = Some [ "podsecuritypolicies" ]
            , verbs = [ "use" ]
            }
          ]
        }
      , ClusterRoleBinding.cadvisor = Kubernetes.RoleBinding::{
        , kind = "ClusterRoleBinding"
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app", mapValue = "cadvisor" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "cadvisor" }
            , { mapKey = "category", mapValue = "rbac" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "cluster-admin"
              }
            ]
          , name = Some "cadvisor"
          }
        , roleRef = Kubernetes.RoleRef::{
          , apiGroup = "rbac.authorization.k8s.io"
          , kind = "ClusterRole"
          , name = "cadvisor"
          }
        , subjects = Some
          [ Kubernetes.Subject::{
            , kind = "ServiceAccount"
            , name = "cadvisor"
            , namespace = Some "default"
            }
          ]
        }
      , DaemonSet.cadvisor = Kubernetes.DaemonSet::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "DaemonSet to ensure all nodes run a cAdvisor pod."
              }
            , { mapKey = "seccomp.security.alpha.kubernetes.io/pod"
              , mapValue = "docker/default"
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "cadvisor" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "cluster-admin"
              }
            ]
          , name = Some "cadvisor"
          }
        , spec = Some Kubernetes.DaemonSetSpec::{
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some [ { mapKey = "app", mapValue = "cadvisor" } ]
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , annotations = Some
                [ { mapKey = "description"
                  , mapValue = "Collects and exports container metrics."
                  }
                , { mapKey = "prometheus.io/port", mapValue = "48080" }
                , { mapKey = "sourcegraph.prometheus/scrape"
                  , mapValue = "true"
                  }
                ]
              , labels = Some
                [ { mapKey = "app", mapValue = "cadvisor" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , automountServiceAccountToken = Some False
              , containers =
                [ Kubernetes.Container::{
                  , args = Some
                    [ "--store_container_labels=false"
                    , "--whitelisted_container_labels=io.kubernetes.container.name,io.kubernetes.pod.name,io.kubernetes.pod.namespace,io.kubernetes.pod.uid"
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/cadvisor:insiders@sha256:fc44bfeb8ac74e8476082cce046a023a6c321348aeb83049328a96c90eda70fb"
                  , name = "cadvisor"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 48080
                      , name = Some "http"
                      , protocol = Some "TCP"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "300m" }
                      , { mapKey = "memory", mapValue = "2000Mi" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "150m" }
                      , { mapKey = "memory", mapValue = "200Mi" }
                      ]
                    }
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/rootfs"
                      , name = "rootfs"
                      , readOnly = Some True
                      }
                    , Kubernetes.VolumeMount::{
                      , mountPath = "/var/run"
                      , name = "var-run"
                      , readOnly = Some True
                      }
                    , Kubernetes.VolumeMount::{
                      , mountPath = "/sys"
                      , name = "sys"
                      , readOnly = Some True
                      }
                    , Kubernetes.VolumeMount::{
                      , mountPath = "/var/lib/docker"
                      , name = "docker"
                      , readOnly = Some True
                      }
                    , Kubernetes.VolumeMount::{
                      , mountPath = "/dev/disk"
                      , name = "disk"
                      , readOnly = Some True
                      }
                    ]
                  }
                ]
              , serviceAccountName = Some "cadvisor"
              , terminationGracePeriodSeconds = Some 30
              , volumes = Some
                [ Kubernetes.Volume::{
                  , hostPath = Some Kubernetes.HostPathVolumeSource::{
                    , path = "/"
                    }
                  , name = "rootfs"
                  }
                , Kubernetes.Volume::{
                  , hostPath = Some Kubernetes.HostPathVolumeSource::{
                    , path = "/var/run"
                    }
                  , name = "var-run"
                  }
                , Kubernetes.Volume::{
                  , hostPath = Some Kubernetes.HostPathVolumeSource::{
                    , path = "/sys"
                    }
                  , name = "sys"
                  }
                , Kubernetes.Volume::{
                  , hostPath = Some Kubernetes.HostPathVolumeSource::{
                    , path = "/var/lib/docker"
                    }
                  , name = "docker"
                  }
                , Kubernetes.Volume::{
                  , hostPath = Some Kubernetes.HostPathVolumeSource::{
                    , path = "/dev/disk"
                    }
                  , name = "disk"
                  }
                ]
              }
            }
          }
        }
      , PodSecurityPolicy.cadvisor = Kubernetes.PodSecurityPolicy::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app", mapValue = "cadvisor" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "cadvisor" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "cluster-admin"
              }
            ]
          , name = Some "cadvisor"
          }
        , spec = Some Kubernetes.PodSecurityPolicySpec::{
          , allowedHostPaths = Some
            [ Kubernetes.AllowedHostPath::{ pathPrefix = Some "/" }
            , Kubernetes.AllowedHostPath::{ pathPrefix = Some "/var/run" }
            , Kubernetes.AllowedHostPath::{ pathPrefix = Some "/sys" }
            , Kubernetes.AllowedHostPath::{
              , pathPrefix = Some "/var/lib/docker"
              }
            , Kubernetes.AllowedHostPath::{ pathPrefix = Some "/dev/disk" }
            ]
          , fsGroup = Kubernetes.SupplementalGroupsStrategyOptions::{
            , rule = Some "RunAsAny"
            }
          , runAsUser = Kubernetes.RunAsUserStrategyOptions::{
            , rule = "RunAsAny"
            }
          , seLinux = Kubernetes.SELinuxStrategyOptions::{ rule = "RunAsAny" }
          , supplementalGroups = Kubernetes.SupplementalGroupsStrategyOptions::{
            , rule = Some "RunAsAny"
            }
          , volumes = Some [ "*" ]
          }
        }
      , ServiceAccount.cadvisor = Kubernetes.ServiceAccount::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app", mapValue = "cadvisor" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "cadvisor" }
            , { mapKey = "category", mapValue = "rbac" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "cluster-admin"
              }
            ]
          , name = Some "cadvisor"
          }
        }
      }
    , Codeintel-Db =
      { ConfigMap.codeintel-db-conf = Kubernetes.ConfigMap::{
        , data = Some
          [ { mapKey = "postgresql.conf"
            , mapValue =
                ''
                # -----------------------------
                # PostgreSQL configuration file
                # -----------------------------
                #
                # This file consists of lines of the form:
                #
                #   name = value
                #
                # (The "=" is optional.)  Whitespace may be used.  Comments are introduced with
                # "#" anywhere on a line.  The complete list of parameter names and allowed
                # values can be found in the PostgreSQL documentation.
                #
                # The commented-out settings shown in this file represent the default values.
                # Re-commenting a setting is NOT sufficient to revert it to the default value;
                # you need to reload the server.
                #
                # This file is read on server startup and when the server receives a SIGHUP
                # signal.  If you edit the file on a running system, you have to SIGHUP the
                # server for the changes to take effect, run "pg_ctl reload", or execute
                # "SELECT pg_reload_conf()".  Some parameters, which are marked below,
                # require a server shutdown and restart to take effect.
                #
                # Any parameter can also be given as a command-line option to the server, e.g.,
                # "postgres -c log_connections=on".  Some parameters can be changed at run time
                # with the "SET" SQL command.
                #
                # Memory units:  kB = kilobytes        Time units:  ms  = milliseconds
                #                MB = megabytes                     s   = seconds
                #                GB = gigabytes                     min = minutes
                #                TB = terabytes                     h   = hours
                #                                                   d   = days


                #------------------------------------------------------------------------------
                # FILE LOCATIONS
                #------------------------------------------------------------------------------

                # The default values of these variables are driven from the -D command-line
                # option or PGDATA environment variable, represented here as ConfigDir.

                #data_directory = 'ConfigDir'		# use data in another directory
                					# (change requires restart)
                #hba_file = 'ConfigDir/pg_hba.conf'	# host-based authentication file
                					# (change requires restart)
                #ident_file = 'ConfigDir/pg_ident.conf'	# ident configuration file
                					# (change requires restart)

                # If external_pid_file is not explicitly set, no extra PID file is written.
                #external_pid_file = '''			# write an extra PID file
                					# (change requires restart)


                #------------------------------------------------------------------------------
                # CONNECTIONS AND AUTHENTICATION
                #------------------------------------------------------------------------------

                # - Connection Settings -

                listen_addresses = '*'
                					# comma-separated list of addresses;
                					# defaults to 'localhost'; use '*' for all
                					# (change requires restart)
                #port = 5432				# (change requires restart)
                max_connections = 100			# (change requires restart)
                #superuser_reserved_connections = 3	# (change requires restart)
                #unix_socket_directories = '/var/run/postgresql'	# comma-separated list of directories
                					# (change requires restart)
                #unix_socket_group = '''			# (change requires restart)
                #unix_socket_permissions = 0777		# begin with 0 to use octal notation
                					# (change requires restart)
                #bonjour = off				# advertise server via Bonjour
                					# (change requires restart)
                #bonjour_name = '''			# defaults to the computer name
                					# (change requires restart)

                # - TCP Keepalives -
                # see "man 7 tcp" for details

                #tcp_keepalives_idle = 0		# TCP_KEEPIDLE, in seconds;
                					# 0 selects the system default
                #tcp_keepalives_interval = 0		# TCP_KEEPINTVL, in seconds;
                					# 0 selects the system default
                #tcp_keepalives_count = 0		# TCP_KEEPCNT;
                					# 0 selects the system default

                # - Authentication -

                #authentication_timeout = 1min		# 1s-600s
                #password_encryption = md5		# md5 or scram-sha-256
                #db_user_namespace = off

                # GSSAPI using Kerberos
                #krb_server_keyfile = '''
                #krb_caseins_users = off

                # - SSL -

                #ssl = off
                #ssl_ca_file = '''
                #ssl_cert_file = 'server.crt'
                #ssl_crl_file = '''
                #ssl_key_file = 'server.key'
                #ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL' # allowed SSL ciphers
                #ssl_prefer_server_ciphers = on
                #ssl_ecdh_curve = 'prime256v1'
                #ssl_dh_params_file = '''
                #ssl_passphrase_command = '''
                #ssl_passphrase_command_supports_reload = off


                #------------------------------------------------------------------------------
                # RESOURCE USAGE (except WAL)
                #------------------------------------------------------------------------------

                # - Memory -

                shared_buffers = 128MB			# min 128kB
                					# (change requires restart)
                #huge_pages = try			# on, off, or try
                					# (change requires restart)
                #temp_buffers = 8MB			# min 800kB
                #max_prepared_transactions = 0		# zero disables the feature
                					# (change requires restart)
                # Caution: it is not advisable to set max_prepared_transactions nonzero unless
                # you actively intend to use prepared transactions.
                #work_mem = 4MB				# min 64kB
                #maintenance_work_mem = 64MB		# min 1MB
                #autovacuum_work_mem = -1		# min 1MB, or -1 to use maintenance_work_mem
                #max_stack_depth = 2MB			# min 100kB
                dynamic_shared_memory_type = posix	# the default is the first option
                					# supported by the operating system:
                					#   posix
                					#   sysv
                					#   windows
                					#   mmap
                					# use none to disable dynamic shared memory
                					# (change requires restart)

                # - Disk -

                #temp_file_limit = -1			# limits per-process temp file space
                					# in kB, or -1 for no limit

                # - Kernel Resources -

                #max_files_per_process = 1000		# min 25
                					# (change requires restart)

                # - Cost-Based Vacuum Delay -

                #vacuum_cost_delay = 0			# 0-100 milliseconds
                #vacuum_cost_page_hit = 1		# 0-10000 credits
                #vacuum_cost_page_miss = 10		# 0-10000 credits
                #vacuum_cost_page_dirty = 20		# 0-10000 credits
                #vacuum_cost_limit = 200		# 1-10000 credits

                # - Background Writer -

                #bgwriter_delay = 200ms			# 10-10000ms between rounds
                #bgwriter_lru_maxpages = 100		# max buffers written/round, 0 disables
                #bgwriter_lru_multiplier = 2.0		# 0-10.0 multiplier on buffers scanned/round
                #bgwriter_flush_after = 512kB		# measured in pages, 0 disables

                # - Asynchronous Behavior -

                #effective_io_concurrency = 1		# 1-1000; 0 disables prefetching
                #max_worker_processes = 8		# (change requires restart)
                #max_parallel_maintenance_workers = 2	# taken from max_parallel_workers
                #max_parallel_workers_per_gather = 2	# taken from max_parallel_workers
                #parallel_leader_participation = on
                #max_parallel_workers = 8		# maximum number of max_worker_processes that
                					# can be used in parallel operations
                #old_snapshot_threshold = -1		# 1min-60d; -1 disables; 0 is immediate
                					# (change requires restart)
                #backend_flush_after = 0		# measured in pages, 0 disables


                #------------------------------------------------------------------------------
                # WRITE-AHEAD LOG
                #------------------------------------------------------------------------------

                # - Settings -

                #wal_level = replica			# minimal, replica, or logical
                					# (change requires restart)
                #fsync = on				# flush data to disk for crash safety
                					# (turning this off can cause
                					# unrecoverable data corruption)
                #synchronous_commit = on		# synchronization level;
                					# off, local, remote_write, remote_apply, or on
                #wal_sync_method = fsync		# the default is the first option
                					# supported by the operating system:
                					#   open_datasync
                					#   fdatasync (default on Linux)
                					#   fsync
                					#   fsync_writethrough
                					#   open_sync
                #full_page_writes = on			# recover from partial page writes
                #wal_compression = off			# enable compression of full-page writes
                #wal_log_hints = off			# also do full page writes of non-critical updates
                					# (change requires restart)
                #wal_buffers = -1			# min 32kB, -1 sets based on shared_buffers
                					# (change requires restart)
                #wal_writer_delay = 200ms		# 1-10000 milliseconds
                #wal_writer_flush_after = 1MB		# measured in pages, 0 disables

                #commit_delay = 0			# range 0-100000, in microseconds
                #commit_siblings = 5			# range 1-1000

                # - Checkpoints -

                #checkpoint_timeout = 5min		# range 30s-1d
                max_wal_size = 1GB
                min_wal_size = 80MB
                #checkpoint_completion_target = 0.5	# checkpoint target duration, 0.0 - 1.0
                #checkpoint_flush_after = 256kB		# measured in pages, 0 disables
                #checkpoint_warning = 30s		# 0 disables

                # - Archiving -

                #archive_mode = off		# enables archiving; off, on, or always
                				# (change requires restart)
                #archive_command = '''		# command to use to archive a logfile segment
                				# placeholders: %p = path of file to archive
                				#               %f = file name only
                				# e.g. 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'
                #archive_timeout = 0		# force a logfile segment switch after this
                				# number of seconds; 0 disables


                #------------------------------------------------------------------------------
                # REPLICATION
                #------------------------------------------------------------------------------

                # - Sending Servers -

                # Set these on the master and on any standby that will send replication data.

                #max_wal_senders = 10		# max number of walsender processes
                				# (change requires restart)
                #wal_keep_segments = 0		# in logfile segments; 0 disables
                #wal_sender_timeout = 60s	# in milliseconds; 0 disables

                #max_replication_slots = 10	# max number of replication slots
                				# (change requires restart)
                #track_commit_timestamp = off	# collect timestamp of transaction commit
                				# (change requires restart)

                # - Master Server -

                # These settings are ignored on a standby server.

                #synchronous_standby_names = '''	# standby servers that provide sync rep
                				# method to choose sync standbys, number of sync standbys,
                				# and comma-separated list of application_name
                				# from standby(s); '*' = all
                #vacuum_defer_cleanup_age = 0	# number of xacts by which cleanup is delayed

                # - Standby Servers -

                # These settings are ignored on a master server.

                #hot_standby = on			# "off" disallows queries during recovery
                					# (change requires restart)
                #max_standby_archive_delay = 30s	# max delay before canceling queries
                					# when reading WAL from archive;
                					# -1 allows indefinite delay
                #max_standby_streaming_delay = 30s	# max delay before canceling queries
                					# when reading streaming WAL;
                					# -1 allows indefinite delay
                #wal_receiver_status_interval = 10s	# send replies at least this often
                					# 0 disables
                #hot_standby_feedback = off		# send info from standby to prevent
                					# query conflicts
                #wal_receiver_timeout = 60s		# time that receiver waits for
                					# communication from master
                					# in milliseconds; 0 disables
                #wal_retrieve_retry_interval = 5s	# time to wait before retrying to
                					# retrieve WAL after a failed attempt

                # - Subscribers -

                # These settings are ignored on a publisher.

                #max_logical_replication_workers = 4	# taken from max_worker_processes
                					# (change requires restart)
                #max_sync_workers_per_subscription = 2	# taken from max_logical_replication_workers


                #------------------------------------------------------------------------------
                # QUERY TUNING
                #------------------------------------------------------------------------------

                # - Planner Method Configuration -

                #enable_bitmapscan = on
                #enable_hashagg = on
                #enable_hashjoin = on
                #enable_indexscan = on
                #enable_indexonlyscan = on
                #enable_material = on
                #enable_mergejoin = on
                #enable_nestloop = on
                #enable_parallel_append = on
                #enable_seqscan = on
                #enable_sort = on
                #enable_tidscan = on
                #enable_partitionwise_join = off
                #enable_partitionwise_aggregate = off
                #enable_parallel_hash = on
                #enable_partition_pruning = on

                # - Planner Cost Constants -

                #seq_page_cost = 1.0			# measured on an arbitrary scale
                #random_page_cost = 4.0			# same scale as above
                #cpu_tuple_cost = 0.01			# same scale as above
                #cpu_index_tuple_cost = 0.005		# same scale as above
                #cpu_operator_cost = 0.0025		# same scale as above
                #parallel_tuple_cost = 0.1		# same scale as above
                #parallel_setup_cost = 1000.0	# same scale as above

                #jit_above_cost = 100000		# perform JIT compilation if available
                					# and query more expensive than this;
                					# -1 disables
                #jit_inline_above_cost = 500000		# inline small functions if query is
                					# more expensive than this; -1 disables
                #jit_optimize_above_cost = 500000	# use expensive JIT optimizations if
                					# query is more expensive than this;
                					# -1 disables

                #min_parallel_table_scan_size = 8MB
                #min_parallel_index_scan_size = 512kB
                #effective_cache_size = 4GB

                # - Genetic Query Optimizer -

                #geqo = on
                #geqo_threshold = 12
                #geqo_effort = 5			# range 1-10
                #geqo_pool_size = 0			# selects default based on effort
                #geqo_generations = 0			# selects default based on effort
                #geqo_selection_bias = 2.0		# range 1.5-2.0
                #geqo_seed = 0.0			# range 0.0-1.0

                # - Other Planner Options -

                #default_statistics_target = 100	# range 1-10000
                #constraint_exclusion = partition	# on, off, or partition
                #cursor_tuple_fraction = 0.1		# range 0.0-1.0
                #from_collapse_limit = 8
                #join_collapse_limit = 8		# 1 disables collapsing of explicit
                					# JOIN clauses
                #force_parallel_mode = off
                #jit = off				# allow JIT compilation


                #------------------------------------------------------------------------------
                # REPORTING AND LOGGING
                #------------------------------------------------------------------------------

                # - Where to Log -

                #log_destination = 'stderr'		# Valid values are combinations of
                					# stderr, csvlog, syslog, and eventlog,
                					# depending on platform.  csvlog
                					# requires logging_collector to be on.

                # This is used when logging to stderr:
                #logging_collector = off		# Enable capturing of stderr and csvlog
                					# into log files. Required to be on for
                					# csvlogs.
                					# (change requires restart)

                # These are only used if logging_collector is on:
                #log_directory = 'log'			# directory where log files are written,
                					# can be absolute or relative to PGDATA
                #log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'	# log file name pattern,
                					# can include strftime() escapes
                #log_file_mode = 0600			# creation mode for log files,
                					# begin with 0 to use octal notation
                #log_truncate_on_rotation = off		# If on, an existing log file with the
                					# same name as the new log file will be
                					# truncated rather than appended to.
                					# But such truncation only occurs on
                					# time-driven rotation, not on restarts
                					# or size-driven rotation.  Default is
                					# off, meaning append to existing files
                					# in all cases.
                #log_rotation_age = 1d			# Automatic rotation of logfiles will
                					# happen after that time.  0 disables.
                #log_rotation_size = 10MB		# Automatic rotation of logfiles will
                					# happen after that much log output.
                					# 0 disables.

                # These are relevant when logging to syslog:
                #syslog_facility = 'LOCAL0'
                #syslog_ident = 'postgres'
                #syslog_sequence_numbers = on
                #syslog_split_messages = on

                # This is only relevant when logging to eventlog (win32):
                # (change requires restart)
                #event_source = 'PostgreSQL'

                # - When to Log -

                #log_min_messages = warning		# values in order of decreasing detail:
                					#   debug5
                					#   debug4
                					#   debug3
                					#   debug2
                					#   debug1
                					#   info
                					#   notice
                					#   warning
                					#   error
                					#   log
                					#   fatal
                					#   panic

                #log_min_error_statement = error	# values in order of decreasing detail:
                					#   debug5
                					#   debug4
                					#   debug3
                					#   debug2
                					#   debug1
                					#   info
                					#   notice
                					#   warning
                					#   error
                					#   log
                					#   fatal
                					#   panic (effectively off)

                #log_min_duration_statement = -1	# -1 is disabled, 0 logs all statements
                					# and their durations, > 0 logs only
                					# statements running at least this number
                					# of milliseconds


                # - What to Log -

                #debug_print_parse = off
                #debug_print_rewritten = off
                #debug_print_plan = off
                #debug_pretty_print = on
                #log_checkpoints = off
                #log_connections = off
                #log_disconnections = off
                #log_duration = off
                #log_error_verbosity = default		# terse, default, or verbose messages
                #log_hostname = off
                #log_line_prefix = '%m [%p] '		# special values:
                					#   %a = application name
                					#   %u = user name
                					#   %d = database name
                					#   %r = remote host and port
                					#   %h = remote host
                					#   %p = process ID
                					#   %t = timestamp without milliseconds
                					#   %m = timestamp with milliseconds
                					#   %n = timestamp with milliseconds (as a Unix epoch)
                					#   %i = command tag
                					#   %e = SQL state
                					#   %c = session ID
                					#   %l = session line number
                					#   %s = session start timestamp
                					#   %v = virtual transaction ID
                					#   %x = transaction ID (0 if none)
                					#   %q = stop here in non-session
                					#        processes
                					#   %% = '%'
                					# e.g. '<%u%%%d> '
                #log_lock_waits = off			# log lock waits >= deadlock_timeout
                #log_statement = 'none'			# none, ddl, mod, all
                #log_replication_commands = off
                #log_temp_files = -1			# log temporary files equal or larger
                					# than the specified size in kilobytes;
                					# -1 disables, 0 logs all temp files
                log_timezone = 'Etc/UTC'

                #------------------------------------------------------------------------------
                # PROCESS TITLE
                #------------------------------------------------------------------------------

                #cluster_name = '''			# added to process titles if nonempty
                					# (change requires restart)
                #update_process_title = on


                #------------------------------------------------------------------------------
                # STATISTICS
                #------------------------------------------------------------------------------

                # - Query and Index Statistics Collector -

                #track_activities = on
                #track_counts = on
                #track_io_timing = off
                #track_functions = none			# none, pl, all
                #track_activity_query_size = 1024	# (change requires restart)
                #stats_temp_directory = 'pg_stat_tmp'


                # - Monitoring -

                #log_parser_stats = off
                #log_planner_stats = off
                #log_executor_stats = off
                #log_statement_stats = off


                #------------------------------------------------------------------------------
                # AUTOVACUUM
                #------------------------------------------------------------------------------

                #autovacuum = on			# Enable autovacuum subprocess?  'on'
                					# requires track_counts to also be on.
                #log_autovacuum_min_duration = -1	# -1 disables, 0 logs all actions and
                					# their durations, > 0 logs only
                					# actions running at least this number
                					# of milliseconds.
                #autovacuum_max_workers = 3		# max number of autovacuum subprocesses
                					# (change requires restart)
                #autovacuum_naptime = 1min		# time between autovacuum runs
                #autovacuum_vacuum_threshold = 50	# min number of row updates before
                					# vacuum
                #autovacuum_analyze_threshold = 50	# min number of row updates before
                					# analyze
                #autovacuum_vacuum_scale_factor = 0.2	# fraction of table size before vacuum
                #autovacuum_analyze_scale_factor = 0.1	# fraction of table size before analyze
                #autovacuum_freeze_max_age = 200000000	# maximum XID age before forced vacuum
                					# (change requires restart)
                #autovacuum_multixact_freeze_max_age = 400000000	# maximum multixact age
                					# before forced vacuum
                					# (change requires restart)
                #autovacuum_vacuum_cost_delay = 20ms	# default vacuum cost delay for
                					# autovacuum, in milliseconds;
                					# -1 means use vacuum_cost_delay
                #autovacuum_vacuum_cost_limit = -1	# default vacuum cost limit for
                					# autovacuum, -1 means use
                					# vacuum_cost_limit


                #------------------------------------------------------------------------------
                # CLIENT CONNECTION DEFAULTS
                #------------------------------------------------------------------------------

                # - Statement Behavior -

                #client_min_messages = notice		# values in order of decreasing detail:
                					#   debug5
                					#   debug4
                					#   debug3
                					#   debug2
                					#   debug1
                					#   log
                					#   notice
                					#   warning
                					#   error
                #search_path = '"$user", public'	# schema names
                #row_security = on
                #default_tablespace = '''		# a tablespace name, ''' uses the default
                #temp_tablespaces = '''			# a list of tablespace names, ''' uses
                					# only default tablespace
                #check_function_bodies = on
                #default_transaction_isolation = 'read committed'
                #default_transaction_read_only = off
                #default_transaction_deferrable = off
                #session_replication_role = 'origin'
                #statement_timeout = 0			# in milliseconds, 0 is disabled
                #lock_timeout = 0			# in milliseconds, 0 is disabled
                #idle_in_transaction_session_timeout = 0	# in milliseconds, 0 is disabled
                #vacuum_freeze_min_age = 50000000
                #vacuum_freeze_table_age = 150000000
                #vacuum_multixact_freeze_min_age = 5000000
                #vacuum_multixact_freeze_table_age = 150000000
                #vacuum_cleanup_index_scale_factor = 0.1	# fraction of total number of tuples
                						# before index cleanup, 0 always performs
                						# index cleanup
                #bytea_output = 'hex'			# hex, escape
                #xmlbinary = 'base64'
                #xmloption = 'content'
                #gin_fuzzy_search_limit = 0
                #gin_pending_list_limit = 4MB

                # - Locale and Formatting -

                datestyle = 'iso, mdy'
                #intervalstyle = 'postgres'
                timezone = 'Etc/UTC'
                #timezone_abbreviations = 'Default'     # Select the set of available time zone
                					# abbreviations.  Currently, there are
                					#   Default
                					#   Australia (historical usage)
                					#   India
                					# You can create your own file in
                					# share/timezonesets/.
                #extra_float_digits = 0			# min -15, max 3
                #client_encoding = sql_ascii		# actually, defaults to database
                					# encoding

                # These settings are initialized by initdb, but they can be changed.
                lc_messages = 'en_US.utf8'			# locale for system error message
                					# strings
                lc_monetary = 'en_US.utf8'			# locale for monetary formatting
                lc_numeric = 'en_US.utf8'			# locale for number formatting
                lc_time = 'en_US.utf8'				# locale for time formatting

                # default configuration for text search
                default_text_search_config = 'pg_catalog.english'

                # - Shared Library Preloading -

                #shared_preload_libraries = '''	# (change requires restart)
                #local_preload_libraries = '''
                #session_preload_libraries = '''
                #jit_provider = 'llvmjit'		# JIT library to use

                # - Other Defaults -

                #dynamic_library_path = '$libdir'


                #------------------------------------------------------------------------------
                # LOCK MANAGEMENT
                #------------------------------------------------------------------------------

                #deadlock_timeout = 1s
                #max_locks_per_transaction = 64		# min 10
                					# (change requires restart)
                #max_pred_locks_per_transaction = 64	# min 10
                					# (change requires restart)
                #max_pred_locks_per_relation = -2	# negative values mean
                					# (max_pred_locks_per_transaction
                					#  / -max_pred_locks_per_relation) - 1
                #max_pred_locks_per_page = 2            # min 0


                #------------------------------------------------------------------------------
                # VERSION AND PLATFORM COMPATIBILITY
                #------------------------------------------------------------------------------

                # - Previous PostgreSQL Versions -

                #array_nulls = on
                #backslash_quote = safe_encoding	# on, off, or safe_encoding
                #default_with_oids = off
                #escape_string_warning = on
                #lo_compat_privileges = off
                #operator_precedence_warning = off
                #quote_all_identifiers = off
                #standard_conforming_strings = on
                #synchronize_seqscans = on

                # - Other Platforms and Clients -

                #transform_null_equals = off


                #------------------------------------------------------------------------------
                # ERROR HANDLING
                #------------------------------------------------------------------------------

                #exit_on_error = off			# terminate session on any error?
                #restart_after_crash = on		# reinitialize after backend crash?
                #data_sync_retry = off			# retry or panic on failure to fsync
                					# data?
                					# (change requires restart)


                #------------------------------------------------------------------------------
                # CONFIG FILE INCLUDES
                #------------------------------------------------------------------------------

                # These options allow settings to be loaded from files other than the
                # default postgresql.conf.

                #include_dir = '''			# include files ending in '.conf' from
                					# a directory, e.g., 'conf.d'
                #include_if_exists = '''			# include file only if it exists
                #include = '''				# include file


                #------------------------------------------------------------------------------
                # CUSTOMIZED OPTIONS
                #------------------------------------------------------------------------------

                # Add settings for extensions here
                ''
            }
          ]
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Configuration for PostgreSQL"
              }
            ]
          , labels = Some
            [ { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "codeintel-db-conf"
          }
        }
      , Deployment.codeintel-db = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Postgres database for various data."
              }
            ]
          , labels = Some
            [ { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "codeintel-db"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , minReadySeconds = Some 10
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some
              [ { mapKey = "app", mapValue = "codeintel-db" } ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , type = Some "Recreate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "codeintel-db" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                , { mapKey = "group", mapValue = "backend" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , image = Some
                      "index.docker.io/sourcegraph/codeintel-db@sha256:63090799b34b3115a387d96fe2227a37999d432b774a1d9b7966b8c5d81b56ad"
                  , livenessProbe = Some Kubernetes.Probe::{
                    , exec = Some Kubernetes.ExecAction::{
                      , command = Some [ "/liveness.sh" ]
                      }
                    , initialDelaySeconds = Some 15
                    }
                  , name = "pgsql"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 5432
                      , name = Some "pgsql"
                      }
                    ]
                  , readinessProbe = Some Kubernetes.Probe::{
                    , exec = Some Kubernetes.ExecAction::{
                      , command = Some [ "/ready.sh" ]
                      }
                    }
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "4" }
                      , { mapKey = "memory", mapValue = "2Gi" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "4" }
                      , { mapKey = "memory", mapValue = "2Gi" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/data"
                      , name = "disk"
                      }
                    , Kubernetes.VolumeMount::{
                      , mountPath = "/conf"
                      , name = "pgsql-conf"
                      }
                    ]
                  }
                , Kubernetes.Container::{
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "DATA_SOURCE_NAME"
                      , value = Some
                          "postgres://sg:@localhost:5432/?sslmode=disable"
                      }
                    ]
                  , image = Some
                      "wrouesnel/postgres_exporter:v0.7.0@sha256:785c919627c06f540d515aac88b7966f352403f73e931e70dc2cbf783146a98b"
                  , name = "pgsql-exporter"
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "10m" }
                      , { mapKey = "memory", mapValue = "50Mi" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "10m" }
                      , { mapKey = "memory", mapValue = "50Mi" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  }
                ]
              , initContainers = Some
                [ Kubernetes.Container::{
                  , command = Some
                    [ "sh"
                    , "-c"
                    , "if [ -d /data/pgdata-11 ]; then chmod 750 /data/pgdata-11; fi"
                    ]
                  , image = Some
                      "sourcegraph/alpine:3.10@sha256:4d05cd5669726fc38823e92320659a6d1ef7879e62268adec5df658a0bacf65c"
                  , name = "correct-data-dir-permissions"
                  , securityContext = Some Kubernetes.SecurityContext::{
                    , runAsUser = Some 0
                    }
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/data"
                      , name = "disk"
                      }
                    ]
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              , volumes = Some
                [ Kubernetes.Volume::{
                  , name = "disk"
                  , persistentVolumeClaim = Some Kubernetes.PersistentVolumeClaimVolumeSource::{
                    , claimName = "codeintel-db"
                    }
                  }
                , Kubernetes.Volume::{
                  , configMap = Some Kubernetes.ConfigMapVolumeSource::{
                    , defaultMode = Some 511
                    , name = Some "codeintel-db-conf"
                    }
                  , name = "pgsql-conf"
                  }
                ]
              }
            }
          }
        }
      , PersistentVolumeClaim.codeintel-db = Kubernetes.PersistentVolumeClaim::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "codeintel-db"
          }
        , spec = Some Kubernetes.PersistentVolumeClaimSpec::{
          , accessModes = Some [ "ReadWriteOnce" ]
          , resources = Some Kubernetes.ResourceRequirements::{
            , requests = Some [ { mapKey = "storage", mapValue = "200Gi" } ]
            }
          , storageClassName = Some "sourcegraph"
          }
        }
      , Service.codeintel-db = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "prometheus.io/port", mapValue = "9187" }
            , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
            ]
          , labels = Some
            [ { mapKey = "app", mapValue = "codeintel-db" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "codeintel-db"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "pgsql"
              , port = 5432
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "pgsql")
              }
            ]
          , selector = Some [ { mapKey = "app", mapValue = "codeintel-db" } ]
          , type = Some "ClusterIP"
          }
        }
      }
    , Frontend =
      { Deployment.sourcegraph-frontend = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Serves the frontend of Sourcegraph via HTTP(S)."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "frontend" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "sourcegraph-frontend"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , minReadySeconds = Some 10
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some
              [ { mapKey = "app", mapValue = "sourcegraph-frontend" } ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , rollingUpdate = Some Kubernetes.RollingUpdateDeployment::{
              , maxSurge = Some (< Int : Natural | String : Text >.Int 2)
              , maxUnavailable = Some (< Int : Natural | String : Text >.Int 0)
              }
            , type = Some "RollingUpdate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "sourcegraph-frontend" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , args = Some [ "serve" ]
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "PGDATABASE"
                      , value = Some "sg"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "PGHOST"
                      , value = Some "pgsql"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "PGPORT"
                      , value = Some "5432"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "PGSSLMODE"
                      , value = Some "disable"
                      }
                    , Kubernetes.EnvVar::{ name = "PGUSER", value = Some "sg" }
                    , Kubernetes.EnvVar::{
                      , name = "CODEINTEL_PGDATABASE"
                      , value = Some "sg"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "CODEINTEL_PGHOST"
                      , value = Some "codeintel-db"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "CODEINTEL_PGPORT"
                      , value = Some "5432"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "CODEINTEL_PGSSLMODE"
                      , value = Some "disable"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "CODEINTEL_PGUSER"
                      , value = Some "sg"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "SRC_GIT_SERVERS"
                      , value = Some "gitserver-0.gitserver:3178"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "POD_NAME"
                      , valueFrom = Some Kubernetes.EnvVarSource::{
                        , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                          , fieldPath = "metadata.name"
                          }
                        }
                      }
                    , Kubernetes.EnvVar::{
                      , name = "CACHE_DIR"
                      , value = Some "/mnt/cache/\$(POD_NAME)"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "GRAFANA_SERVER_URL"
                      , value = Some "http://grafana:30070"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "JAEGER_SERVER_URL"
                      , value = Some "http://jaeger-query:16686"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "PRECISE_CODE_INTEL_BUNDLE_MANAGER_URL"
                      , value = Some
                          "http://precise-code-intel-bundle-manager:3187"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "PROMETHEUS_URL"
                      , value = Some "http://prometheus:30090"
                      }
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/frontend:insiders@sha256:834e9a0420c4490775bccb45a2e1e28b27dee9314eca56f8e605f84ff82b2cd9"
                  , livenessProbe = Some Kubernetes.Probe::{
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/healthz"
                      , port = < Int : Natural | String : Text >.String "http"
                      , scheme = Some "HTTP"
                      }
                    , initialDelaySeconds = Some 300
                    , timeoutSeconds = Some 5
                    }
                  , name = "frontend"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 3080
                      , name = Some "http"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 3090
                      , name = Some "http-internal"
                      }
                    ]
                  , readinessProbe = Some Kubernetes.Probe::{
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/healthz"
                      , port = < Int : Natural | String : Text >.String "http"
                      , scheme = Some "HTTP"
                      }
                    , periodSeconds = Some 5
                    , timeoutSeconds = Some 5
                    }
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "2" }
                      , { mapKey = "memory", mapValue = "4G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "2" }
                      , { mapKey = "memory", mapValue = "2G" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/mnt/cache"
                      , name = "cache-ssd"
                      }
                    ]
                  }
                , Kubernetes.Container::{
                  , args = Some
                    [ "--reporter.grpc.host-port=jaeger-collector:14250"
                    , "--reporter.type=grpc"
                    ]
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "POD_NAME"
                      , valueFrom = Some Kubernetes.EnvVarSource::{
                        , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                          , apiVersion = Some "v1"
                          , fieldPath = "metadata.name"
                          }
                        }
                      }
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/jaeger-agent:insiders@sha256:f3faf496fe750ce75e6304f9ac10d8e1f42c9c9bdab3ab0c2fbf77a8d26084a4"
                  , name = "jaeger-agent"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 5775
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 5778
                      , protocol = Some "TCP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6831
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6832
                      , protocol = Some "UDP"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "500M" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "100m" }
                      , { mapKey = "memory", mapValue = "100M" }
                      ]
                    }
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              , serviceAccountName = Some "sourcegraph-frontend"
              , volumes = Some
                [ Kubernetes.Volume::{
                  , emptyDir = Some Kubernetes.EmptyDirVolumeSource::{=}
                  , name = "cache-ssd"
                  }
                ]
              }
            }
          }
        }
      , Ingress.sourcegraph-frontend = Kubernetes.Ingress::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "kubernetes.io/ingress.class", mapValue = "nginx" }
            , { mapKey = "nginx.ingress.kubernetes.io/proxy-body-size"
              , mapValue = "150m"
              }
            ]
          , labels = Some
            [ { mapKey = "app", mapValue = "sourcegraph-frontend" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "frontend" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "sourcegraph-frontend"
          }
        , spec = Some Kubernetes.IngressSpec::{
          , rules = Some
            [ Kubernetes.IngressRule::{
              , http = Some Kubernetes.HTTPIngressRuleValue::{
                , paths =
                  [ Kubernetes.HTTPIngressPath::{
                    , backend = Kubernetes.IngressBackend::{
                      , serviceName = Some "sourcegraph-frontend"
                      , servicePort = Some
                          (< Int : Natural | String : Text >.Int 30080)
                      }
                    , path = Some "/"
                    }
                  ]
                }
              }
            ]
          }
        }
      , Role.sourcegraph-frontend = Kubernetes.Role::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "frontend" }
            , { mapKey = "category", mapValue = "rbac" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "cluster-admin"
              }
            ]
          , name = Some "sourcegraph-frontend"
          }
        , rules = Some
          [ Kubernetes.PolicyRule::{
            , apiGroups = Some [ "" ]
            , resources = Some [ "endpoints", "services" ]
            , verbs = [ "get", "list", "watch" ]
            }
          ]
        }
      , RoleBinding.sourcegraph-frontend = Kubernetes.RoleBinding::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "frontend" }
            , { mapKey = "category", mapValue = "rbac" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "cluster-admin"
              }
            ]
          , name = Some "sourcegraph-frontend"
          }
        , roleRef = Kubernetes.RoleRef::{
          , apiGroup = "rbac.authorization.k8s.io"
          , kind = "Role"
          , name = "sourcegraph-frontend"
          }
        , subjects = Some
          [ Kubernetes.Subject::{
            , kind = "ServiceAccount"
            , name = "sourcegraph-frontend"
            }
          ]
        }
      , Service =
        { sourcegraph-frontend = Kubernetes.Service::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "prometheus.io/port", mapValue = "6060" }
              , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
              ]
            , labels = Some
              [ { mapKey = "app", mapValue = "sourcegraph-frontend" }
              , { mapKey = "app.kubernetes.io/component"
                , mapValue = "frontend"
                }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "sourcegraph-frontend"
            }
          , spec = Some Kubernetes.ServiceSpec::{
            , ports = Some
              [ Kubernetes.ServicePort::{
                , name = Some "http"
                , port = 30080
                , targetPort = Some
                    (< Int : Natural | String : Text >.String "http")
                }
              ]
            , selector = Some
              [ { mapKey = "app", mapValue = "sourcegraph-frontend" } ]
            , type = Some "ClusterIP"
            }
          }
        , sourcegraph-frontend-internal = Kubernetes.Service::{
          , metadata = Kubernetes.ObjectMeta::{
            , labels = Some
              [ { mapKey = "app", mapValue = "sourcegraph-frontend" }
              , { mapKey = "app.kubernetes.io/component"
                , mapValue = "frontend"
                }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "sourcegraph-frontend-internal"
            }
          , spec = Some Kubernetes.ServiceSpec::{
            , ports = Some
              [ Kubernetes.ServicePort::{
                , name = Some "http-internal"
                , port = 80
                , targetPort = Some
                    (< Int : Natural | String : Text >.String "http-internal")
                }
              ]
            , selector = Some
              [ { mapKey = "app", mapValue = "sourcegraph-frontend" } ]
            , type = Some "ClusterIP"
            }
          }
        }
      , ServiceAccount.sourcegraph-frontend = Kubernetes.ServiceAccount::{
        , imagePullSecrets = Some
          [ Kubernetes.LocalObjectReference::{ name = Some "docker-registry" } ]
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "frontend" }
            , { mapKey = "category", mapValue = "rbac" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "sourcegraph-frontend"
          }
        }
      }
    , Github-Proxy =
      { Deployment.github-proxy = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Rate-limiting proxy for the GitHub API."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "github-proxy"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "github-proxy"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , minReadySeconds = Some 10
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some
              [ { mapKey = "app", mapValue = "github-proxy" } ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , rollingUpdate = Some Kubernetes.RollingUpdateDeployment::{
              , maxSurge = Some (< Int : Natural | String : Text >.Int 1)
              , maxUnavailable = Some (< Int : Natural | String : Text >.Int 0)
              }
            , type = Some "RollingUpdate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "github-proxy" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , image = Some
                      "index.docker.io/sourcegraph/github-proxy:insiders@sha256:a810d5dc7ab026af65ab2d971856bf288495abd8045556900fc5f92ce497e0e8"
                  , name = "github-proxy"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 3180
                      , name = Some "http"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "1G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "100m" }
                      , { mapKey = "memory", mapValue = "250M" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  }
                , Kubernetes.Container::{
                  , args = Some
                    [ "--reporter.grpc.host-port=jaeger-collector:14250"
                    , "--reporter.type=grpc"
                    ]
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "POD_NAME"
                      , valueFrom = Some Kubernetes.EnvVarSource::{
                        , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                          , apiVersion = Some "v1"
                          , fieldPath = "metadata.name"
                          }
                        }
                      }
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/jaeger-agent:insiders@sha256:f3faf496fe750ce75e6304f9ac10d8e1f42c9c9bdab3ab0c2fbf77a8d26084a4"
                  , name = "jaeger-agent"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 5775
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 5778
                      , protocol = Some "TCP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6831
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6832
                      , protocol = Some "UDP"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "500M" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "100m" }
                      , { mapKey = "memory", mapValue = "100M" }
                      ]
                    }
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              }
            }
          }
        }
      , Service.github-proxy = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "prometheus.io/port", mapValue = "6060" }
            , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
            ]
          , labels = Some
            [ { mapKey = "app", mapValue = "github-proxy" }
            , { mapKey = "app.kubernetes.io/component"
              , mapValue = "github-proxy"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "github-proxy"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "http"
              , port = 80
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "http")
              }
            ]
          , selector = Some [ { mapKey = "app", mapValue = "github-proxy" } ]
          , type = Some "ClusterIP"
          }
        }
      }
    , Gitserver =
      { Service.gitserver = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue =
                  "Headless service that provides a stable network identity for the gitserver stateful set."
              }
            , { mapKey = "prometheus.io/port", mapValue = "6060" }
            , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
            ]
          , labels = Some
            [ { mapKey = "app", mapValue = "gitserver" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "gitserver" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            , { mapKey = "type", mapValue = "gitserver" }
            ]
          , name = Some "gitserver"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , clusterIP = Some "None"
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "unused"
              , port = 10811
              , targetPort = Some (< Int : Natural | String : Text >.Int 10811)
              }
            ]
          , selector = Some
            [ { mapKey = "app", mapValue = "gitserver" }
            , { mapKey = "type", mapValue = "gitserver" }
            ]
          , type = Some "ClusterIP"
          }
        }
      , StatefulSet.gitserver = Kubernetes.StatefulSet::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue =
                  "Stores clones of repositories to perform Git operations."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "gitserver" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "gitserver"
          }
        , spec = Some Kubernetes.StatefulSetSpec::{
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some [ { mapKey = "app", mapValue = "gitserver" } ]
            }
          , serviceName = "gitserver"
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "gitserver" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                , { mapKey = "group", mapValue = "backend" }
                , { mapKey = "type", mapValue = "gitserver" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , args = Some [ "run" ]
                  , image = Some
                      "index.docker.io/sourcegraph/gitserver:insiders@sha256:a6fdd7d889a2e4a76f22cfa4fe8fd4775895b8213329ca5ef2c2bf0515cb1a51"
                  , livenessProbe = Some Kubernetes.Probe::{
                    , initialDelaySeconds = Some 5
                    , tcpSocket = Some Kubernetes.TCPSocketAction::{
                      , port = < Int : Natural | String : Text >.String "rpc"
                      }
                    , timeoutSeconds = Some 5
                    }
                  , name = "gitserver"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 3178
                      , name = Some "rpc"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "4" }
                      , { mapKey = "memory", mapValue = "8G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "4" }
                      , { mapKey = "memory", mapValue = "8G" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/data/repos"
                      , name = "repos"
                      }
                    ]
                  }
                , Kubernetes.Container::{
                  , args = Some
                    [ "--reporter.grpc.host-port=jaeger-collector:14250"
                    , "--reporter.type=grpc"
                    ]
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "POD_NAME"
                      , valueFrom = Some Kubernetes.EnvVarSource::{
                        , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                          , apiVersion = Some "v1"
                          , fieldPath = "metadata.name"
                          }
                        }
                      }
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/jaeger-agent:insiders@sha256:f3faf496fe750ce75e6304f9ac10d8e1f42c9c9bdab3ab0c2fbf77a8d26084a4"
                  , name = "jaeger-agent"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 5775
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 5778
                      , protocol = Some "TCP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6831
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6832
                      , protocol = Some "UDP"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "500M" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "100m" }
                      , { mapKey = "memory", mapValue = "100M" }
                      ]
                    }
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              , volumes = Some [ Kubernetes.Volume::{ name = "repos" } ]
              }
            }
          , updateStrategy = Some Kubernetes.StatefulSetUpdateStrategy::{
            , type = Some "RollingUpdate"
            }
          , volumeClaimTemplates = Some
            [ Kubernetes.PersistentVolumeClaim::{
              , apiVersion = "apps/v1"
              , metadata = Kubernetes.ObjectMeta::{ name = Some "repos" }
              , spec = Some Kubernetes.PersistentVolumeClaimSpec::{
                , accessModes = Some [ "ReadWriteOnce" ]
                , resources = Some Kubernetes.ResourceRequirements::{
                  , requests = Some
                    [ { mapKey = "storage", mapValue = "200Gi" } ]
                  }
                , storageClassName = Some "sourcegraph"
                }
              }
            ]
          }
        }
      }
    , Grafana =
      { ConfigMap.grafana = Kubernetes.ConfigMap::{
        , data = Some
          [ { mapKey = "datasources.yml"
            , mapValue =
                ''
                apiVersion: 1

                datasources:
                  - name: Prometheus
                    type: prometheus
                    access: proxy
                    url: http://prometheus:30090
                    isDefault: true
                    editable: false
                  - name: Jaeger
                    type: Jaeger
                    access: proxy
                    url: http://jaeger-query:16686/-/debug/jaeger
                ''
            }
          ]
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "grafana" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "grafana"
          }
        }
      , Service.grafana = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app", mapValue = "grafana" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "grafana" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "grafana"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "http"
              , port = 30070
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "http")
              }
            ]
          , selector = Some [ { mapKey = "app", mapValue = "grafana" } ]
          , type = Some "ClusterIP"
          }
        }
      , ServiceAccount.grafana = Kubernetes.ServiceAccount::{
        , imagePullSecrets = Some
          [ Kubernetes.LocalObjectReference::{ name = Some "docker-registry" } ]
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "grafana" }
            , { mapKey = "category", mapValue = "rbac" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "grafana"
          }
        }
      , StatefulSet.grafana = Kubernetes.StatefulSet::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Metrics/monitoring dashboards and alerts."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "grafana" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "grafana"
          }
        , spec = Some Kubernetes.StatefulSetSpec::{
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some [ { mapKey = "app", mapValue = "grafana" } ]
            }
          , serviceName = "grafana"
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "grafana" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , image = Some
                      "index.docker.io/sourcegraph/grafana:insiders@sha256:6cde769ff3d80fdd34666d6cc785445cb4779369d4037590fda7c4eed4ddcca5"
                  , name = "grafana"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 3370
                      , name = Some "http"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "512Mi" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "100m" }
                      , { mapKey = "memory", mapValue = "512Mi" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/var/lib/grafana"
                      , name = "grafana-data"
                      }
                    , Kubernetes.VolumeMount::{
                      , mountPath =
                          "/sg_config_grafana/provisioning/datasources"
                      , name = "config"
                      }
                    ]
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              , serviceAccountName = Some "grafana"
              , volumes = Some
                [ Kubernetes.Volume::{
                  , configMap = Some Kubernetes.ConfigMapVolumeSource::{
                    , defaultMode = Some 511
                    , name = Some "grafana"
                    }
                  , name = "config"
                  }
                ]
              }
            }
          , updateStrategy = Some Kubernetes.StatefulSetUpdateStrategy::{
            , type = Some "RollingUpdate"
            }
          , volumeClaimTemplates = Some
            [ Kubernetes.PersistentVolumeClaim::{
              , apiVersion = "apps/v1"
              , metadata = Kubernetes.ObjectMeta::{ name = Some "grafana-data" }
              , spec = Some Kubernetes.PersistentVolumeClaimSpec::{
                , accessModes = Some [ "ReadWriteOnce" ]
                , resources = Some Kubernetes.ResourceRequirements::{
                  , requests = Some [ { mapKey = "storage", mapValue = "2Gi" } ]
                  }
                , storageClassName = Some "sourcegraph"
                }
              }
            ]
          }
        }
      }
    , Indexed-Search =
      { Service =
        { indexed-search = Kubernetes.Service::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "description"
                , mapValue =
                    "Headless service that provides a stable network identity for the indexed-search stateful set."
                }
              , { mapKey = "prometheus.io/port", mapValue = "6070" }
              , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
              ]
            , labels = Some
              [ { mapKey = "app", mapValue = "indexed-search" }
              , { mapKey = "app.kubernetes.io/component"
                , mapValue = "indexed-search"
                }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "indexed-search"
            }
          , spec = Some Kubernetes.ServiceSpec::{
            , clusterIP = Some "None"
            , ports = Some [ Kubernetes.ServicePort::{ port = 6070 } ]
            , selector = Some
              [ { mapKey = "app", mapValue = "indexed-search" } ]
            , type = Some "ClusterIP"
            }
          }
        , indexed-search-indexer = Kubernetes.Service::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "description"
                , mapValue =
                    "Headless service that provides a stable network identity for the indexed-search stateful set."
                }
              , { mapKey = "prometheus.io/port", mapValue = "6072" }
              , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
              ]
            , labels = Some
              [ { mapKey = "app", mapValue = "indexed-search-indexer" }
              , { mapKey = "app.kubernetes.io/component"
                , mapValue = "indexed-search"
                }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "indexed-search-indexer"
            }
          , spec = Some Kubernetes.ServiceSpec::{
            , clusterIP = Some "None"
            , ports = Some
              [ Kubernetes.ServicePort::{
                , port = 6072
                , targetPort = Some (< Int : Natural | String : Text >.Int 6072)
                }
              ]
            , selector = Some
              [ { mapKey = "app", mapValue = "indexed-search" } ]
            , type = Some "ClusterIP"
            }
          }
        }
      , StatefulSet.indexed-search = Kubernetes.StatefulSet::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Backend for indexed text search operations."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "indexed-search"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "indexed-search"
          }
        , spec = Some Kubernetes.StatefulSetSpec::{
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some
              [ { mapKey = "app", mapValue = "indexed-search" } ]
            }
          , serviceName = "indexed-search"
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "indexed-search" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , image = Some
                      "index.docker.io/sourcegraph/indexed-searcher:insiders@sha256:fcf03182a79aaf48252f74e47204088a2db4f11620c97dfbca0721f61521fe3c"
                  , name = "zoekt-webserver"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 6070
                      , name = Some "http"
                      }
                    ]
                  , readinessProbe = Some Kubernetes.Probe::{
                    , failureThreshold = Some 3
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/healthz"
                      , port = < Int : Natural | String : Text >.String "http"
                      , scheme = Some "HTTP"
                      }
                    , periodSeconds = Some 5
                    , timeoutSeconds = Some 5
                    }
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "2" }
                      , { mapKey = "memory", mapValue = "4G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "500m" }
                      , { mapKey = "memory", mapValue = "2G" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/data"
                      , name = "data"
                      }
                    ]
                  }
                , Kubernetes.Container::{
                  , image = Some
                      "index.docker.io/sourcegraph/search-indexer:insiders@sha256:315e2f1994d80cf0cdbc3c9d46a568f406b3a08ce4f6dd372a4225bcfebc4f2f"
                  , name = "zoekt-indexserver"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 6072
                      , name = Some "index-http"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "8" }
                      , { mapKey = "memory", mapValue = "8G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "4" }
                      , { mapKey = "memory", mapValue = "4G" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/data"
                      , name = "data"
                      }
                    ]
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              , volumes = Some [ Kubernetes.Volume::{ name = "data" } ]
              }
            }
          , updateStrategy = Some Kubernetes.StatefulSetUpdateStrategy::{
            , type = Some "RollingUpdate"
            }
          , volumeClaimTemplates = Some
            [ Kubernetes.PersistentVolumeClaim::{
              , apiVersion = "apps/v1"
              , metadata = Kubernetes.ObjectMeta::{
                , labels = Some
                  [ { mapKey = "deploy", mapValue = "sourcegraph" } ]
                , name = Some "data"
                }
              , spec = Some Kubernetes.PersistentVolumeClaimSpec::{
                , accessModes = Some [ "ReadWriteOnce" ]
                , resources = Some Kubernetes.ResourceRequirements::{
                  , requests = Some
                    [ { mapKey = "storage", mapValue = "200Gi" } ]
                  }
                , storageClassName = Some "sourcegraph"
                }
              }
            ]
          }
        }
      }
    , Jaeger =
      { Deployment.jaeger = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app", mapValue = "jaeger" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "jaeger" }
            , { mapKey = "app.kubernetes.io/name", mapValue = "jaeger" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "jaeger"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , replicas = Some 1
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some
              [ { mapKey = "app", mapValue = "jaeger" }
              , { mapKey = "app.kubernetes.io/component"
                , mapValue = "all-in-one"
                }
              , { mapKey = "app.kubernetes.io/name", mapValue = "jaeger" }
              ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , type = Some "Recreate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , annotations = Some
                [ { mapKey = "prometheus.io/port", mapValue = "16686" }
                , { mapKey = "prometheus.io/scrape", mapValue = "true" }
                ]
              , labels = Some
                [ { mapKey = "app", mapValue = "jaeger" }
                , { mapKey = "app.kubernetes.io/component"
                  , mapValue = "all-in-one"
                  }
                , { mapKey = "app.kubernetes.io/name", mapValue = "jaeger" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , args = Some [ "--memory.max-traces=20000" ]
                  , image = Some
                      "index.docker.io/sourcegraph/jaeger-all-in-one:insiders@sha256:b723668550f539dc211cd6e1943edb0a0871af4f58e55e9b0ec7523109322e3d"
                  , name = "jaeger"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 5775
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6831
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6832
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 5778
                      , protocol = Some "TCP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 16686
                      , protocol = Some "TCP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 14250
                      , protocol = Some "TCP"
                      }
                    ]
                  , readinessProbe = Some Kubernetes.Probe::{
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/"
                      , port = < Int : Natural | String : Text >.Int 14269
                      }
                    , initialDelaySeconds = Some 5
                    }
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "1G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "500m" }
                      , { mapKey = "memory", mapValue = "500M" }
                      ]
                    }
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              }
            }
          }
        }
      , Service =
        { jaeger-collector = Kubernetes.Service::{
          , metadata = Kubernetes.ObjectMeta::{
            , labels = Some
              [ { mapKey = "app", mapValue = "jaeger" }
              , { mapKey = "app.kubernetes.io/component", mapValue = "jaeger" }
              , { mapKey = "app.kubernetes.io/name", mapValue = "jaeger" }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "jaeger-collector"
            }
          , spec = Some Kubernetes.ServiceSpec::{
            , ports = Some
              [ Kubernetes.ServicePort::{
                , name = Some "jaeger-collector-tchannel"
                , port = 14267
                , protocol = Some "TCP"
                , targetPort = Some
                    (< Int : Natural | String : Text >.Int 14267)
                }
              , Kubernetes.ServicePort::{
                , name = Some "jaeger-collector-http"
                , port = 14268
                , protocol = Some "TCP"
                , targetPort = Some
                    (< Int : Natural | String : Text >.Int 14268)
                }
              , Kubernetes.ServicePort::{
                , name = Some "jaeger-collector-grpc"
                , port = 14250
                , protocol = Some "TCP"
                , targetPort = Some
                    (< Int : Natural | String : Text >.Int 14250)
                }
              ]
            , selector = Some
              [ { mapKey = "app.kubernetes.io/component"
                , mapValue = "all-in-one"
                }
              , { mapKey = "app.kubernetes.io/name", mapValue = "jaeger" }
              ]
            , type = Some "ClusterIP"
            }
          }
        , jaeger-query = Kubernetes.Service::{
          , metadata = Kubernetes.ObjectMeta::{
            , labels = Some
              [ { mapKey = "app", mapValue = "jaeger" }
              , { mapKey = "app.kubernetes.io/component", mapValue = "jaeger" }
              , { mapKey = "app.kubernetes.io/name", mapValue = "jaeger" }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "jaeger-query"
            }
          , spec = Some Kubernetes.ServiceSpec::{
            , ports = Some
              [ Kubernetes.ServicePort::{
                , name = Some "query-http"
                , port = 16686
                , protocol = Some "TCP"
                , targetPort = Some
                    (< Int : Natural | String : Text >.Int 16686)
                }
              ]
            , selector = Some
              [ { mapKey = "app.kubernetes.io/component"
                , mapValue = "all-in-one"
                }
              , { mapKey = "app.kubernetes.io/name", mapValue = "jaeger" }
              ]
            , type = Some "ClusterIP"
            }
          }
        }
      }
    , Pgsql =
      { ConfigMap.pgsql-conf = Kubernetes.ConfigMap::{
        , data = Some
          [ { mapKey = "postgresql.conf"
            , mapValue =
                ''
                # -----------------------------
                # PostgreSQL configuration file
                # -----------------------------
                #
                # This file consists of lines of the form:
                #
                #   name = value
                #
                # (The "=" is optional.)  Whitespace may be used.  Comments are introduced with
                # "#" anywhere on a line.  The complete list of parameter names and allowed
                # values can be found in the PostgreSQL documentation.
                #
                # The commented-out settings shown in this file represent the default values.
                # Re-commenting a setting is NOT sufficient to revert it to the default value;
                # you need to reload the server.
                #
                # This file is read on server startup and when the server receives a SIGHUP
                # signal.  If you edit the file on a running system, you have to SIGHUP the
                # server for the changes to take effect, run "pg_ctl reload", or execute
                # "SELECT pg_reload_conf()".  Some parameters, which are marked below,
                # require a server shutdown and restart to take effect.
                #
                # Any parameter can also be given as a command-line option to the server, e.g.,
                # "postgres -c log_connections=on".  Some parameters can be changed at run time
                # with the "SET" SQL command.
                #
                # Memory units:  kB = kilobytes        Time units:  ms  = milliseconds
                #                MB = megabytes                     s   = seconds
                #                GB = gigabytes                     min = minutes
                #                TB = terabytes                     h   = hours
                #                                                   d   = days


                #------------------------------------------------------------------------------
                # FILE LOCATIONS
                #------------------------------------------------------------------------------

                # The default values of these variables are driven from the -D command-line
                # option or PGDATA environment variable, represented here as ConfigDir.

                #data_directory = 'ConfigDir'		# use data in another directory
                					# (change requires restart)
                #hba_file = 'ConfigDir/pg_hba.conf'	# host-based authentication file
                					# (change requires restart)
                #ident_file = 'ConfigDir/pg_ident.conf'	# ident configuration file
                					# (change requires restart)

                # If external_pid_file is not explicitly set, no extra PID file is written.
                #external_pid_file = '''			# write an extra PID file
                					# (change requires restart)


                #------------------------------------------------------------------------------
                # CONNECTIONS AND AUTHENTICATION
                #------------------------------------------------------------------------------

                # - Connection Settings -

                listen_addresses = '*'
                					# comma-separated list of addresses;
                					# defaults to 'localhost'; use '*' for all
                					# (change requires restart)
                #port = 5432				# (change requires restart)
                max_connections = 100			# (change requires restart)
                #superuser_reserved_connections = 3	# (change requires restart)
                #unix_socket_directories = '/var/run/postgresql'	# comma-separated list of directories
                					# (change requires restart)
                #unix_socket_group = '''			# (change requires restart)
                #unix_socket_permissions = 0777		# begin with 0 to use octal notation
                					# (change requires restart)
                #bonjour = off				# advertise server via Bonjour
                					# (change requires restart)
                #bonjour_name = '''			# defaults to the computer name
                					# (change requires restart)

                # - TCP Keepalives -
                # see "man 7 tcp" for details

                #tcp_keepalives_idle = 0		# TCP_KEEPIDLE, in seconds;
                					# 0 selects the system default
                #tcp_keepalives_interval = 0		# TCP_KEEPINTVL, in seconds;
                					# 0 selects the system default
                #tcp_keepalives_count = 0		# TCP_KEEPCNT;
                					# 0 selects the system default

                # - Authentication -

                #authentication_timeout = 1min		# 1s-600s
                #password_encryption = md5		# md5 or scram-sha-256
                #db_user_namespace = off

                # GSSAPI using Kerberos
                #krb_server_keyfile = '''
                #krb_caseins_users = off

                # - SSL -

                #ssl = off
                #ssl_ca_file = '''
                #ssl_cert_file = 'server.crt'
                #ssl_crl_file = '''
                #ssl_key_file = 'server.key'
                #ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL' # allowed SSL ciphers
                #ssl_prefer_server_ciphers = on
                #ssl_ecdh_curve = 'prime256v1'
                #ssl_dh_params_file = '''
                #ssl_passphrase_command = '''
                #ssl_passphrase_command_supports_reload = off


                #------------------------------------------------------------------------------
                # RESOURCE USAGE (except WAL)
                #------------------------------------------------------------------------------

                # - Memory -

                shared_buffers = 128MB			# min 128kB
                					# (change requires restart)
                #huge_pages = try			# on, off, or try
                					# (change requires restart)
                #temp_buffers = 8MB			# min 800kB
                #max_prepared_transactions = 0		# zero disables the feature
                					# (change requires restart)
                # Caution: it is not advisable to set max_prepared_transactions nonzero unless
                # you actively intend to use prepared transactions.
                #work_mem = 4MB				# min 64kB
                #maintenance_work_mem = 64MB		# min 1MB
                #autovacuum_work_mem = -1		# min 1MB, or -1 to use maintenance_work_mem
                #max_stack_depth = 2MB			# min 100kB
                dynamic_shared_memory_type = posix	# the default is the first option
                					# supported by the operating system:
                					#   posix
                					#   sysv
                					#   windows
                					#   mmap
                					# use none to disable dynamic shared memory
                					# (change requires restart)

                # - Disk -

                #temp_file_limit = -1			# limits per-process temp file space
                					# in kB, or -1 for no limit

                # - Kernel Resources -

                #max_files_per_process = 1000		# min 25
                					# (change requires restart)

                # - Cost-Based Vacuum Delay -

                #vacuum_cost_delay = 0			# 0-100 milliseconds
                #vacuum_cost_page_hit = 1		# 0-10000 credits
                #vacuum_cost_page_miss = 10		# 0-10000 credits
                #vacuum_cost_page_dirty = 20		# 0-10000 credits
                #vacuum_cost_limit = 200		# 1-10000 credits

                # - Background Writer -

                #bgwriter_delay = 200ms			# 10-10000ms between rounds
                #bgwriter_lru_maxpages = 100		# max buffers written/round, 0 disables
                #bgwriter_lru_multiplier = 2.0		# 0-10.0 multiplier on buffers scanned/round
                #bgwriter_flush_after = 512kB		# measured in pages, 0 disables

                # - Asynchronous Behavior -

                #effective_io_concurrency = 1		# 1-1000; 0 disables prefetching
                #max_worker_processes = 8		# (change requires restart)
                #max_parallel_maintenance_workers = 2	# taken from max_parallel_workers
                #max_parallel_workers_per_gather = 2	# taken from max_parallel_workers
                #parallel_leader_participation = on
                #max_parallel_workers = 8		# maximum number of max_worker_processes that
                					# can be used in parallel operations
                #old_snapshot_threshold = -1		# 1min-60d; -1 disables; 0 is immediate
                					# (change requires restart)
                #backend_flush_after = 0		# measured in pages, 0 disables


                #------------------------------------------------------------------------------
                # WRITE-AHEAD LOG
                #------------------------------------------------------------------------------

                # - Settings -

                #wal_level = replica			# minimal, replica, or logical
                					# (change requires restart)
                #fsync = on				# flush data to disk for crash safety
                					# (turning this off can cause
                					# unrecoverable data corruption)
                #synchronous_commit = on		# synchronization level;
                					# off, local, remote_write, remote_apply, or on
                #wal_sync_method = fsync		# the default is the first option
                					# supported by the operating system:
                					#   open_datasync
                					#   fdatasync (default on Linux)
                					#   fsync
                					#   fsync_writethrough
                					#   open_sync
                #full_page_writes = on			# recover from partial page writes
                #wal_compression = off			# enable compression of full-page writes
                #wal_log_hints = off			# also do full page writes of non-critical updates
                					# (change requires restart)
                #wal_buffers = -1			# min 32kB, -1 sets based on shared_buffers
                					# (change requires restart)
                #wal_writer_delay = 200ms		# 1-10000 milliseconds
                #wal_writer_flush_after = 1MB		# measured in pages, 0 disables

                #commit_delay = 0			# range 0-100000, in microseconds
                #commit_siblings = 5			# range 1-1000

                # - Checkpoints -

                #checkpoint_timeout = 5min		# range 30s-1d
                max_wal_size = 1GB
                min_wal_size = 80MB
                #checkpoint_completion_target = 0.5	# checkpoint target duration, 0.0 - 1.0
                #checkpoint_flush_after = 256kB		# measured in pages, 0 disables
                #checkpoint_warning = 30s		# 0 disables

                # - Archiving -

                #archive_mode = off		# enables archiving; off, on, or always
                				# (change requires restart)
                #archive_command = '''		# command to use to archive a logfile segment
                				# placeholders: %p = path of file to archive
                				#               %f = file name only
                				# e.g. 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'
                #archive_timeout = 0		# force a logfile segment switch after this
                				# number of seconds; 0 disables


                #------------------------------------------------------------------------------
                # REPLICATION
                #------------------------------------------------------------------------------

                # - Sending Servers -

                # Set these on the master and on any standby that will send replication data.

                #max_wal_senders = 10		# max number of walsender processes
                				# (change requires restart)
                #wal_keep_segments = 0		# in logfile segments; 0 disables
                #wal_sender_timeout = 60s	# in milliseconds; 0 disables

                #max_replication_slots = 10	# max number of replication slots
                				# (change requires restart)
                #track_commit_timestamp = off	# collect timestamp of transaction commit
                				# (change requires restart)

                # - Master Server -

                # These settings are ignored on a standby server.

                #synchronous_standby_names = '''	# standby servers that provide sync rep
                				# method to choose sync standbys, number of sync standbys,
                				# and comma-separated list of application_name
                				# from standby(s); '*' = all
                #vacuum_defer_cleanup_age = 0	# number of xacts by which cleanup is delayed

                # - Standby Servers -

                # These settings are ignored on a master server.

                #hot_standby = on			# "off" disallows queries during recovery
                					# (change requires restart)
                #max_standby_archive_delay = 30s	# max delay before canceling queries
                					# when reading WAL from archive;
                					# -1 allows indefinite delay
                #max_standby_streaming_delay = 30s	# max delay before canceling queries
                					# when reading streaming WAL;
                					# -1 allows indefinite delay
                #wal_receiver_status_interval = 10s	# send replies at least this often
                					# 0 disables
                #hot_standby_feedback = off		# send info from standby to prevent
                					# query conflicts
                #wal_receiver_timeout = 60s		# time that receiver waits for
                					# communication from master
                					# in milliseconds; 0 disables
                #wal_retrieve_retry_interval = 5s	# time to wait before retrying to
                					# retrieve WAL after a failed attempt

                # - Subscribers -

                # These settings are ignored on a publisher.

                #max_logical_replication_workers = 4	# taken from max_worker_processes
                					# (change requires restart)
                #max_sync_workers_per_subscription = 2	# taken from max_logical_replication_workers


                #------------------------------------------------------------------------------
                # QUERY TUNING
                #------------------------------------------------------------------------------

                # - Planner Method Configuration -

                #enable_bitmapscan = on
                #enable_hashagg = on
                #enable_hashjoin = on
                #enable_indexscan = on
                #enable_indexonlyscan = on
                #enable_material = on
                #enable_mergejoin = on
                #enable_nestloop = on
                #enable_parallel_append = on
                #enable_seqscan = on
                #enable_sort = on
                #enable_tidscan = on
                #enable_partitionwise_join = off
                #enable_partitionwise_aggregate = off
                #enable_parallel_hash = on
                #enable_partition_pruning = on

                # - Planner Cost Constants -

                #seq_page_cost = 1.0			# measured on an arbitrary scale
                #random_page_cost = 4.0			# same scale as above
                #cpu_tuple_cost = 0.01			# same scale as above
                #cpu_index_tuple_cost = 0.005		# same scale as above
                #cpu_operator_cost = 0.0025		# same scale as above
                #parallel_tuple_cost = 0.1		# same scale as above
                #parallel_setup_cost = 1000.0	# same scale as above

                #jit_above_cost = 100000		# perform JIT compilation if available
                					# and query more expensive than this;
                					# -1 disables
                #jit_inline_above_cost = 500000		# inline small functions if query is
                					# more expensive than this; -1 disables
                #jit_optimize_above_cost = 500000	# use expensive JIT optimizations if
                					# query is more expensive than this;
                					# -1 disables

                #min_parallel_table_scan_size = 8MB
                #min_parallel_index_scan_size = 512kB
                #effective_cache_size = 4GB

                # - Genetic Query Optimizer -

                #geqo = on
                #geqo_threshold = 12
                #geqo_effort = 5			# range 1-10
                #geqo_pool_size = 0			# selects default based on effort
                #geqo_generations = 0			# selects default based on effort
                #geqo_selection_bias = 2.0		# range 1.5-2.0
                #geqo_seed = 0.0			# range 0.0-1.0

                # - Other Planner Options -

                #default_statistics_target = 100	# range 1-10000
                #constraint_exclusion = partition	# on, off, or partition
                #cursor_tuple_fraction = 0.1		# range 0.0-1.0
                #from_collapse_limit = 8
                #join_collapse_limit = 8		# 1 disables collapsing of explicit
                					# JOIN clauses
                #force_parallel_mode = off
                #jit = off				# allow JIT compilation


                #------------------------------------------------------------------------------
                # REPORTING AND LOGGING
                #------------------------------------------------------------------------------

                # - Where to Log -

                #log_destination = 'stderr'		# Valid values are combinations of
                					# stderr, csvlog, syslog, and eventlog,
                					# depending on platform.  csvlog
                					# requires logging_collector to be on.

                # This is used when logging to stderr:
                #logging_collector = off		# Enable capturing of stderr and csvlog
                					# into log files. Required to be on for
                					# csvlogs.
                					# (change requires restart)

                # These are only used if logging_collector is on:
                #log_directory = 'log'			# directory where log files are written,
                					# can be absolute or relative to PGDATA
                #log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'	# log file name pattern,
                					# can include strftime() escapes
                #log_file_mode = 0600			# creation mode for log files,
                					# begin with 0 to use octal notation
                #log_truncate_on_rotation = off		# If on, an existing log file with the
                					# same name as the new log file will be
                					# truncated rather than appended to.
                					# But such truncation only occurs on
                					# time-driven rotation, not on restarts
                					# or size-driven rotation.  Default is
                					# off, meaning append to existing files
                					# in all cases.
                #log_rotation_age = 1d			# Automatic rotation of logfiles will
                					# happen after that time.  0 disables.
                #log_rotation_size = 10MB		# Automatic rotation of logfiles will
                					# happen after that much log output.
                					# 0 disables.

                # These are relevant when logging to syslog:
                #syslog_facility = 'LOCAL0'
                #syslog_ident = 'postgres'
                #syslog_sequence_numbers = on
                #syslog_split_messages = on

                # This is only relevant when logging to eventlog (win32):
                # (change requires restart)
                #event_source = 'PostgreSQL'

                # - When to Log -

                #log_min_messages = warning		# values in order of decreasing detail:
                					#   debug5
                					#   debug4
                					#   debug3
                					#   debug2
                					#   debug1
                					#   info
                					#   notice
                					#   warning
                					#   error
                					#   log
                					#   fatal
                					#   panic

                #log_min_error_statement = error	# values in order of decreasing detail:
                					#   debug5
                					#   debug4
                					#   debug3
                					#   debug2
                					#   debug1
                					#   info
                					#   notice
                					#   warning
                					#   error
                					#   log
                					#   fatal
                					#   panic (effectively off)

                #log_min_duration_statement = -1	# -1 is disabled, 0 logs all statements
                					# and their durations, > 0 logs only
                					# statements running at least this number
                					# of milliseconds


                # - What to Log -

                #debug_print_parse = off
                #debug_print_rewritten = off
                #debug_print_plan = off
                #debug_pretty_print = on
                #log_checkpoints = off
                #log_connections = off
                #log_disconnections = off
                #log_duration = off
                #log_error_verbosity = default		# terse, default, or verbose messages
                #log_hostname = off
                #log_line_prefix = '%m [%p] '		# special values:
                					#   %a = application name
                					#   %u = user name
                					#   %d = database name
                					#   %r = remote host and port
                					#   %h = remote host
                					#   %p = process ID
                					#   %t = timestamp without milliseconds
                					#   %m = timestamp with milliseconds
                					#   %n = timestamp with milliseconds (as a Unix epoch)
                					#   %i = command tag
                					#   %e = SQL state
                					#   %c = session ID
                					#   %l = session line number
                					#   %s = session start timestamp
                					#   %v = virtual transaction ID
                					#   %x = transaction ID (0 if none)
                					#   %q = stop here in non-session
                					#        processes
                					#   %% = '%'
                					# e.g. '<%u%%%d> '
                #log_lock_waits = off			# log lock waits >= deadlock_timeout
                #log_statement = 'none'			# none, ddl, mod, all
                #log_replication_commands = off
                #log_temp_files = -1			# log temporary files equal or larger
                					# than the specified size in kilobytes;
                					# -1 disables, 0 logs all temp files
                log_timezone = 'Etc/UTC'

                #------------------------------------------------------------------------------
                # PROCESS TITLE
                #------------------------------------------------------------------------------

                #cluster_name = '''			# added to process titles if nonempty
                					# (change requires restart)
                #update_process_title = on


                #------------------------------------------------------------------------------
                # STATISTICS
                #------------------------------------------------------------------------------

                # - Query and Index Statistics Collector -

                #track_activities = on
                #track_counts = on
                #track_io_timing = off
                #track_functions = none			# none, pl, all
                #track_activity_query_size = 1024	# (change requires restart)
                #stats_temp_directory = 'pg_stat_tmp'


                # - Monitoring -

                #log_parser_stats = off
                #log_planner_stats = off
                #log_executor_stats = off
                #log_statement_stats = off


                #------------------------------------------------------------------------------
                # AUTOVACUUM
                #------------------------------------------------------------------------------

                #autovacuum = on			# Enable autovacuum subprocess?  'on'
                					# requires track_counts to also be on.
                #log_autovacuum_min_duration = -1	# -1 disables, 0 logs all actions and
                					# their durations, > 0 logs only
                					# actions running at least this number
                					# of milliseconds.
                #autovacuum_max_workers = 3		# max number of autovacuum subprocesses
                					# (change requires restart)
                #autovacuum_naptime = 1min		# time between autovacuum runs
                #autovacuum_vacuum_threshold = 50	# min number of row updates before
                					# vacuum
                #autovacuum_analyze_threshold = 50	# min number of row updates before
                					# analyze
                #autovacuum_vacuum_scale_factor = 0.2	# fraction of table size before vacuum
                #autovacuum_analyze_scale_factor = 0.1	# fraction of table size before analyze
                #autovacuum_freeze_max_age = 200000000	# maximum XID age before forced vacuum
                					# (change requires restart)
                #autovacuum_multixact_freeze_max_age = 400000000	# maximum multixact age
                					# before forced vacuum
                					# (change requires restart)
                #autovacuum_vacuum_cost_delay = 20ms	# default vacuum cost delay for
                					# autovacuum, in milliseconds;
                					# -1 means use vacuum_cost_delay
                #autovacuum_vacuum_cost_limit = -1	# default vacuum cost limit for
                					# autovacuum, -1 means use
                					# vacuum_cost_limit


                #------------------------------------------------------------------------------
                # CLIENT CONNECTION DEFAULTS
                #------------------------------------------------------------------------------

                # - Statement Behavior -

                #client_min_messages = notice		# values in order of decreasing detail:
                					#   debug5
                					#   debug4
                					#   debug3
                					#   debug2
                					#   debug1
                					#   log
                					#   notice
                					#   warning
                					#   error
                #search_path = '"$user", public'	# schema names
                #row_security = on
                #default_tablespace = '''		# a tablespace name, ''' uses the default
                #temp_tablespaces = '''			# a list of tablespace names, ''' uses
                					# only default tablespace
                #check_function_bodies = on
                #default_transaction_isolation = 'read committed'
                #default_transaction_read_only = off
                #default_transaction_deferrable = off
                #session_replication_role = 'origin'
                #statement_timeout = 0			# in milliseconds, 0 is disabled
                #lock_timeout = 0			# in milliseconds, 0 is disabled
                #idle_in_transaction_session_timeout = 0	# in milliseconds, 0 is disabled
                #vacuum_freeze_min_age = 50000000
                #vacuum_freeze_table_age = 150000000
                #vacuum_multixact_freeze_min_age = 5000000
                #vacuum_multixact_freeze_table_age = 150000000
                #vacuum_cleanup_index_scale_factor = 0.1	# fraction of total number of tuples
                						# before index cleanup, 0 always performs
                						# index cleanup
                #bytea_output = 'hex'			# hex, escape
                #xmlbinary = 'base64'
                #xmloption = 'content'
                #gin_fuzzy_search_limit = 0
                #gin_pending_list_limit = 4MB

                # - Locale and Formatting -

                datestyle = 'iso, mdy'
                #intervalstyle = 'postgres'
                timezone = 'Etc/UTC'
                #timezone_abbreviations = 'Default'     # Select the set of available time zone
                					# abbreviations.  Currently, there are
                					#   Default
                					#   Australia (historical usage)
                					#   India
                					# You can create your own file in
                					# share/timezonesets/.
                #extra_float_digits = 0			# min -15, max 3
                #client_encoding = sql_ascii		# actually, defaults to database
                					# encoding

                # These settings are initialized by initdb, but they can be changed.
                lc_messages = 'en_US.utf8'			# locale for system error message
                					# strings
                lc_monetary = 'en_US.utf8'			# locale for monetary formatting
                lc_numeric = 'en_US.utf8'			# locale for number formatting
                lc_time = 'en_US.utf8'				# locale for time formatting

                # default configuration for text search
                default_text_search_config = 'pg_catalog.english'

                # - Shared Library Preloading -

                #shared_preload_libraries = '''	# (change requires restart)
                #local_preload_libraries = '''
                #session_preload_libraries = '''
                #jit_provider = 'llvmjit'		# JIT library to use

                # - Other Defaults -

                #dynamic_library_path = '$libdir'


                #------------------------------------------------------------------------------
                # LOCK MANAGEMENT
                #------------------------------------------------------------------------------

                #deadlock_timeout = 1s
                #max_locks_per_transaction = 64		# min 10
                					# (change requires restart)
                #max_pred_locks_per_transaction = 64	# min 10
                					# (change requires restart)
                #max_pred_locks_per_relation = -2	# negative values mean
                					# (max_pred_locks_per_transaction
                					#  / -max_pred_locks_per_relation) - 1
                #max_pred_locks_per_page = 2            # min 0


                #------------------------------------------------------------------------------
                # VERSION AND PLATFORM COMPATIBILITY
                #------------------------------------------------------------------------------

                # - Previous PostgreSQL Versions -

                #array_nulls = on
                #backslash_quote = safe_encoding	# on, off, or safe_encoding
                #default_with_oids = off
                #escape_string_warning = on
                #lo_compat_privileges = off
                #operator_precedence_warning = off
                #quote_all_identifiers = off
                #standard_conforming_strings = on
                #synchronize_seqscans = on

                # - Other Platforms and Clients -

                #transform_null_equals = off


                #------------------------------------------------------------------------------
                # ERROR HANDLING
                #------------------------------------------------------------------------------

                #exit_on_error = off			# terminate session on any error?
                #restart_after_crash = on		# reinitialize after backend crash?
                #data_sync_retry = off			# retry or panic on failure to fsync
                					# data?
                					# (change requires restart)


                #------------------------------------------------------------------------------
                # CONFIG FILE INCLUDES
                #------------------------------------------------------------------------------

                # These options allow settings to be loaded from files other than the
                # default postgresql.conf.

                #include_dir = '''			# include files ending in '.conf' from
                					# a directory, e.g., 'conf.d'
                #include_if_exists = '''			# include file only if it exists
                #include = '''				# include file


                #------------------------------------------------------------------------------
                # CUSTOMIZED OPTIONS
                #------------------------------------------------------------------------------

                # Add settings for extensions here
                ''
            }
          ]
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Configuration for PostgreSQL"
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "pgsql" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "pgsql-conf"
          }
        }
      , Deployment.pgsql = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Postgres database for various data."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "pgsql" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "pgsql"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , minReadySeconds = Some 10
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some [ { mapKey = "app", mapValue = "pgsql" } ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , type = Some "Recreate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "pgsql" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                , { mapKey = "group", mapValue = "backend" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , image = Some
                      "index.docker.io/sourcegraph/postgres-11.4:insiders@sha256:63090799b34b3115a387d96fe2227a37999d432b774a1d9b7966b8c5d81b56ad"
                  , livenessProbe = Some Kubernetes.Probe::{
                    , exec = Some Kubernetes.ExecAction::{
                      , command = Some [ "/liveness.sh" ]
                      }
                    , initialDelaySeconds = Some 15
                    }
                  , name = "pgsql"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 5432
                      , name = Some "pgsql"
                      }
                    ]
                  , readinessProbe = Some Kubernetes.Probe::{
                    , exec = Some Kubernetes.ExecAction::{
                      , command = Some [ "/ready.sh" ]
                      }
                    }
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "4" }
                      , { mapKey = "memory", mapValue = "2Gi" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "4" }
                      , { mapKey = "memory", mapValue = "2Gi" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/data"
                      , name = "disk"
                      }
                    , Kubernetes.VolumeMount::{
                      , mountPath = "/conf"
                      , name = "pgsql-conf"
                      }
                    ]
                  }
                , Kubernetes.Container::{
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "DATA_SOURCE_NAME"
                      , value = Some
                          "postgres://sg:@localhost:5432/?sslmode=disable"
                      }
                    ]
                  , image = Some
                      "wrouesnel/postgres_exporter:v0.7.0@sha256:785c919627c06f540d515aac88b7966f352403f73e931e70dc2cbf783146a98b"
                  , name = "pgsql-exporter"
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "10m" }
                      , { mapKey = "memory", mapValue = "50Mi" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "10m" }
                      , { mapKey = "memory", mapValue = "50Mi" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  }
                ]
              , initContainers = Some
                [ Kubernetes.Container::{
                  , command = Some
                    [ "sh"
                    , "-c"
                    , "if [ -d /data/pgdata-11 ]; then chmod 750 /data/pgdata-11; fi"
                    ]
                  , image = Some
                      "sourcegraph/alpine:3.12@sha256:133a0a767b836cf86a011101995641cf1b5cbefb3dd212d78d7be145adde636d"
                  , name = "correct-data-dir-permissions"
                  , securityContext = Some Kubernetes.SecurityContext::{
                    , runAsUser = Some 0
                    }
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/data"
                      , name = "disk"
                      }
                    ]
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              , volumes = Some
                [ Kubernetes.Volume::{
                  , name = "disk"
                  , persistentVolumeClaim = Some Kubernetes.PersistentVolumeClaimVolumeSource::{
                    , claimName = "pgsql"
                    }
                  }
                , Kubernetes.Volume::{
                  , configMap = Some Kubernetes.ConfigMapVolumeSource::{
                    , defaultMode = Some 511
                    , name = Some "pgsql-conf"
                    }
                  , name = "pgsql-conf"
                  }
                ]
              }
            }
          }
        }
      , PersistentVolumeClaim.pgsql = Kubernetes.PersistentVolumeClaim::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "pgsql" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "pgsql"
          }
        , spec = Some Kubernetes.PersistentVolumeClaimSpec::{
          , accessModes = Some [ "ReadWriteOnce" ]
          , resources = Some Kubernetes.ResourceRequirements::{
            , requests = Some [ { mapKey = "storage", mapValue = "200Gi" } ]
            }
          , storageClassName = Some "sourcegraph"
          }
        }
      , Service.pgsql = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "prometheus.io/port", mapValue = "9187" }
            , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
            ]
          , labels = Some
            [ { mapKey = "app", mapValue = "pgsql" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "pgsql" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "pgsql"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "pgsql"
              , port = 5432
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "pgsql")
              }
            ]
          , selector = Some [ { mapKey = "app", mapValue = "pgsql" } ]
          , type = Some "ClusterIP"
          }
        }
      }
    , Precise-Code-Intel =
      { Deployment =
        { precise-code-intel-bundle-manager = Kubernetes.Deployment::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "description"
                , mapValue =
                    "Stores and manages precise code intelligence bundles."
                }
              ]
            , labels = Some
              [ { mapKey = "app.kubernetes.io/component"
                , mapValue = "precise-code-intel"
                }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "precise-code-intel-bundle-manager"
            }
          , spec = Some Kubernetes.DeploymentSpec::{
            , minReadySeconds = Some 10
            , replicas = Some 1
            , revisionHistoryLimit = Some 10
            , selector = Kubernetes.LabelSelector::{
              , matchLabels = Some
                [ { mapKey = "app"
                  , mapValue = "precise-code-intel-bundle-manager"
                  }
                ]
              }
            , strategy = Some Kubernetes.DeploymentStrategy::{
              , type = Some "Recreate"
              }
            , template = Kubernetes.PodTemplateSpec::{
              , metadata = Kubernetes.ObjectMeta::{
                , labels = Some
                  [ { mapKey = "app"
                    , mapValue = "precise-code-intel-bundle-manager"
                    }
                  , { mapKey = "deploy", mapValue = "sourcegraph" }
                  ]
                }
              , spec = Some Kubernetes.PodSpec::{
                , containers =
                  [ Kubernetes.Container::{
                    , env = Some
                      [ Kubernetes.EnvVar::{
                        , name = "PRECISE_CODE_INTEL_BUNDLE_DIR"
                        , value = Some "/lsif-storage"
                        }
                      , Kubernetes.EnvVar::{
                        , name = "POD_NAME"
                        , valueFrom = Some Kubernetes.EnvVarSource::{
                          , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                            , fieldPath = "metadata.name"
                            }
                          }
                        }
                      ]
                    , image = Some
                        "index.docker.io/sourcegraph/precise-code-intel-bundle-manager:insiders@sha256:defc89dbf8713541c08321acbab5d145099a300703949d938b491be68617d351"
                    , livenessProbe = Some Kubernetes.Probe::{
                      , httpGet = Some Kubernetes.HTTPGetAction::{
                        , path = Some "/healthz"
                        , port = < Int : Natural | String : Text >.String "http"
                        , scheme = Some "HTTP"
                        }
                      , initialDelaySeconds = Some 60
                      , timeoutSeconds = Some 5
                      }
                    , name = "precise-code-intel-bundle-manager"
                    , ports = Some
                      [ Kubernetes.ContainerPort::{
                        , containerPort = 3187
                        , name = Some "http"
                        }
                      , Kubernetes.ContainerPort::{
                        , containerPort = 6060
                        , name = Some "debug"
                        }
                      ]
                    , readinessProbe = Some Kubernetes.Probe::{
                      , httpGet = Some Kubernetes.HTTPGetAction::{
                        , path = Some "/healthz"
                        , port = < Int : Natural | String : Text >.String "http"
                        , scheme = Some "HTTP"
                        }
                      , periodSeconds = Some 5
                      , timeoutSeconds = Some 5
                      }
                    , resources = Some Kubernetes.ResourceRequirements::{
                      , limits = Some
                        [ { mapKey = "cpu", mapValue = "2" }
                        , { mapKey = "memory", mapValue = "2G" }
                        ]
                      , requests = Some
                        [ { mapKey = "cpu", mapValue = "500m" }
                        , { mapKey = "memory", mapValue = "500M" }
                        ]
                      }
                    , terminationMessagePolicy = Some "FallbackToLogsOnError"
                    , volumeMounts = Some
                      [ Kubernetes.VolumeMount::{
                        , mountPath = "/lsif-storage"
                        , name = "bundle-manager"
                        }
                      ]
                    }
                  ]
                , securityContext = Some Kubernetes.PodSecurityContext::{
                  , runAsUser = Some 0
                  }
                , volumes = Some
                  [ Kubernetes.Volume::{
                    , name = "bundle-manager"
                    , persistentVolumeClaim = Some Kubernetes.PersistentVolumeClaimVolumeSource::{
                      , claimName = "bundle-manager"
                      }
                    }
                  ]
                }
              }
            }
          }
        , precise-code-intel-worker = Kubernetes.Deployment::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "description"
                , mapValue =
                    "Handles conversion of uploaded precise code intelligence bundles."
                }
              ]
            , labels = Some
              [ { mapKey = "app.kubernetes.io/component"
                , mapValue = "precise-code-intel"
                }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "precise-code-intel-worker"
            }
          , spec = Some Kubernetes.DeploymentSpec::{
            , minReadySeconds = Some 10
            , replicas = Some 1
            , revisionHistoryLimit = Some 10
            , selector = Kubernetes.LabelSelector::{
              , matchLabels = Some
                [ { mapKey = "app", mapValue = "precise-code-intel-worker" } ]
              }
            , strategy = Some Kubernetes.DeploymentStrategy::{
              , rollingUpdate = Some Kubernetes.RollingUpdateDeployment::{
                , maxSurge = Some (< Int : Natural | String : Text >.Int 1)
                , maxUnavailable = Some
                    (< Int : Natural | String : Text >.Int 1)
                }
              , type = Some "RollingUpdate"
              }
            , template = Kubernetes.PodTemplateSpec::{
              , metadata = Kubernetes.ObjectMeta::{
                , labels = Some
                  [ { mapKey = "app", mapValue = "precise-code-intel-worker" }
                  , { mapKey = "deploy", mapValue = "sourcegraph" }
                  ]
                }
              , spec = Some Kubernetes.PodSpec::{
                , containers =
                  [ Kubernetes.Container::{
                    , env = Some
                      [ Kubernetes.EnvVar::{
                        , name = "NUM_WORKERS"
                        , value = Some "4"
                        }
                      , Kubernetes.EnvVar::{
                        , name = "PRECISE_CODE_INTEL_BUNDLE_MANAGER_URL"
                        , value = Some
                            "http://precise-code-intel-bundle-manager:3187"
                        }
                      , Kubernetes.EnvVar::{
                        , name = "POD_NAME"
                        , valueFrom = Some Kubernetes.EnvVarSource::{
                          , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                            , fieldPath = "metadata.name"
                            }
                          }
                        }
                      ]
                    , image = Some
                        "index.docker.io/sourcegraph/precise-code-intel-worker:insiders@sha256:7ad054d00a04777c11d42fa27d805b5f421b77b93ed6c112bdd89ad54c8da77d"
                    , livenessProbe = Some Kubernetes.Probe::{
                      , httpGet = Some Kubernetes.HTTPGetAction::{
                        , path = Some "/healthz"
                        , port = < Int : Natural | String : Text >.String "http"
                        , scheme = Some "HTTP"
                        }
                      , initialDelaySeconds = Some 60
                      , timeoutSeconds = Some 5
                      }
                    , name = "precise-code-intel-worker"
                    , ports = Some
                      [ Kubernetes.ContainerPort::{
                        , containerPort = 3188
                        , name = Some "http"
                        }
                      , Kubernetes.ContainerPort::{
                        , containerPort = 6060
                        , name = Some "debug"
                        }
                      ]
                    , readinessProbe = Some Kubernetes.Probe::{
                      , httpGet = Some Kubernetes.HTTPGetAction::{
                        , path = Some "/healthz"
                        , port = < Int : Natural | String : Text >.String "http"
                        , scheme = Some "HTTP"
                        }
                      , periodSeconds = Some 5
                      , timeoutSeconds = Some 5
                      }
                    , resources = Some Kubernetes.ResourceRequirements::{
                      , limits = Some
                        [ { mapKey = "cpu", mapValue = "2" }
                        , { mapKey = "memory", mapValue = "4G" }
                        ]
                      , requests = Some
                        [ { mapKey = "cpu", mapValue = "500m" }
                        , { mapKey = "memory", mapValue = "2G" }
                        ]
                      }
                    , terminationMessagePolicy = Some "FallbackToLogsOnError"
                    }
                  ]
                , securityContext = Some Kubernetes.PodSecurityContext::{
                  , runAsUser = Some 0
                  }
                }
              }
            }
          }
        }
      , PersistentVolumeClaim.bundle-manager = Kubernetes.PersistentVolumeClaim::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "precise-code-intel"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "bundle-manager"
          }
        , spec = Some Kubernetes.PersistentVolumeClaimSpec::{
          , accessModes = Some [ "ReadWriteOnce" ]
          , resources = Some Kubernetes.ResourceRequirements::{
            , requests = Some [ { mapKey = "storage", mapValue = "200Gi" } ]
            }
          , storageClassName = Some "sourcegraph"
          }
        }
      , Service =
        { precise-code-intel-bundle-manager = Kubernetes.Service::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "prometheus.io/port", mapValue = "6060" }
              , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
              ]
            , labels = Some
              [ { mapKey = "app"
                , mapValue = "precise-code-intel-bundle-manager"
                }
              , { mapKey = "app.kubernetes.io/component"
                , mapValue = "precise-code-intel"
                }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "precise-code-intel-bundle-manager"
            }
          , spec = Some Kubernetes.ServiceSpec::{
            , ports = Some
              [ Kubernetes.ServicePort::{
                , name = Some "http"
                , port = 3187
                , targetPort = Some
                    (< Int : Natural | String : Text >.String "http")
                }
              , Kubernetes.ServicePort::{
                , name = Some "debug"
                , port = 6060
                , targetPort = Some
                    (< Int : Natural | String : Text >.String "debug")
                }
              ]
            , selector = Some
              [ { mapKey = "app"
                , mapValue = "precise-code-intel-bundle-manager"
                }
              ]
            , type = Some "ClusterIP"
            }
          }
        , precise-code-intel-worker = Kubernetes.Service::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "prometheus.io/port", mapValue = "6060" }
              , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
              ]
            , labels = Some
              [ { mapKey = "app", mapValue = "precise-code-intel-worker" }
              , { mapKey = "app.kubernetes.io/component"
                , mapValue = "precise-code-intel"
                }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "precise-code-intel-worker"
            }
          , spec = Some Kubernetes.ServiceSpec::{
            , ports = Some
              [ Kubernetes.ServicePort::{
                , name = Some "http"
                , port = 3188
                , targetPort = Some
                    (< Int : Natural | String : Text >.String "http")
                }
              , Kubernetes.ServicePort::{
                , name = Some "debug"
                , port = 6060
                , targetPort = Some
                    (< Int : Natural | String : Text >.String "debug")
                }
              ]
            , selector = Some
              [ { mapKey = "app", mapValue = "precise-code-intel-worker" } ]
            , type = Some "ClusterIP"
            }
          }
        }
      }
    , Prometheus =
      { ClusterRole.prometheus = Kubernetes.ClusterRole::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "prometheus"
              }
            , { mapKey = "category", mapValue = "rbac" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "cluster-admin"
              }
            ]
          , name = Some "prometheus"
          }
        , rules = Some
          [ Kubernetes.PolicyRule::{
            , apiGroups = Some [ "" ]
            , resources = Some
              [ "endpoints"
              , "namespaces"
              , "nodes"
              , "nodes/metrics"
              , "nodes/proxy"
              , "pods"
              , "services"
              ]
            , verbs = [ "get", "list", "watch" ]
            }
          , Kubernetes.PolicyRule::{
            , apiGroups = Some [ "" ]
            , resources = Some [ "configmaps" ]
            , verbs = [ "get" ]
            }
          , Kubernetes.PolicyRule::{
            , nonResourceURLs = Some [ "/metrics" ]
            , verbs = [ "get" ]
            }
          ]
        }
      , ClusterRoleBinding.prometheus = Kubernetes.RoleBinding::{
        , kind = "ClusterRoleBinding"
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "prometheus"
              }
            , { mapKey = "category", mapValue = "rbac" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "cluster-admin"
              }
            ]
          , name = Some "prometheus"
          }
        , roleRef = Kubernetes.RoleRef::{
          , apiGroup = "rbac.authorization.k8s.io"
          , kind = "ClusterRole"
          , name = "prometheus"
          }
        , subjects = Some
          [ Kubernetes.Subject::{
            , kind = "ServiceAccount"
            , name = "prometheus"
            , namespace = Some "default"
            }
          ]
        }
      , ConfigMap.prometheus = Kubernetes.ConfigMap::{
        , data = Some
          [ { mapKey = "extra_rules.yml", mapValue = "" }
          , { mapKey = "prometheus.yml"
            , mapValue =
                ''
                global:
                  scrape_interval:     30s
                  evaluation_interval: 30s

                alerting:
                  alertmanagers:
                    # Bundled Alertmanager, started by prom-wrapper
                    - static_configs:
                        - targets: ['127.0.0.1:9093']
                      path_prefix: /alertmanager
                    # Uncomment the following to have alerts delivered to additional Alertmanagers discovered
                    # in the cluster. This configuration is not required if you use Sourcegraph's built-in alerting:
                    # https://docs.sourcegraph.com/admin/observability/alerting
                    # - kubernetes_sd_configs:
                    #  - role: endpoints
                    #  relabel_configs:
                    #    - source_labels: [__meta_kubernetes_service_name]
                    #      regex: alertmanager
                    #      action: keep

                rule_files:
                  - '*_rules.yml'
                  - "/sg_config_prometheus/*_rules.yml"
                  - "/sg_prometheus_add_ons/*_rules.yml"

                # A scrape configuration for running Prometheus on a Kubernetes cluster.
                # This uses separate scrape configs for cluster components (i.e. API server, node)
                # and services to allow each to use different authentication configs.
                #
                # Kubernetes labels will be added as Prometheus labels on metrics via the
                # `labelmap` relabeling action.

                # Scrape config for API servers.
                #
                # Kubernetes exposes API servers as endpoints to the default/kubernetes
                # service so this uses `endpoints` role and uses relabelling to only keep
                # the endpoints associated with the default/kubernetes service using the
                # default named port `https`. This works for single API server deployments as
                # well as HA API server deployments.
                scrape_configs:
                - job_name: 'kubernetes-apiservers'

                  kubernetes_sd_configs:
                  - role: endpoints

                  # Default to scraping over https. If required, just disable this or change to
                  # `http`.
                  scheme: https

                  # This TLS & bearer token file config is used to connect to the actual scrape
                  # endpoints for cluster components. This is separate to discovery auth
                  # configuration because discovery & scraping are two separate concerns in
                  # Prometheus. The discovery auth config is automatic if Prometheus runs inside
                  # the cluster. Otherwise, more config options have to be provided within the
                  # <kubernetes_sd_config>.
                  tls_config:
                    ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                    # If your node certificates are self-signed or use a different CA to the
                    # master CA, then disable certificate verification below. Note that
                    # certificate verification is an integral part of a secure infrastructure
                    # so this should only be disabled in a controlled environment. You can
                    # disable certificate verification by uncommenting the line below.
                    #
                    # insecure_skip_verify: true
                  bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token

                  # Keep only the default/kubernetes service endpoints for the https port. This
                  # will add targets for each API server which Kubernetes adds an endpoint to
                  # the default/kubernetes service.
                  relabel_configs:
                  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]
                    action: keep
                    regex: default;kubernetes;https

                - job_name: 'kubernetes-nodes'

                  # Default to scraping over https. If required, just disable this or change to
                  # `http`.
                  scheme: https

                  # This TLS & bearer token file config is used to connect to the actual scrape
                  # endpoints for cluster components. This is separate to discovery auth
                  # configuration because discovery & scraping are two separate concerns in
                  # Prometheus. The discovery auth config is automatic if Prometheus runs inside
                  # the cluster. Otherwise, more config options have to be provided within the
                  # <kubernetes_sd_config>.
                  tls_config:
                    ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                    # If your node certificates are self-signed or use a different CA to the
                    # master CA, then disable certificate verification below. Note that
                    # certificate verification is an integral part of a secure infrastructure
                    # so this should only be disabled in a controlled environment. You can
                    # disable certificate verification by uncommenting the line below.
                    #
                    insecure_skip_verify: true
                  bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token

                  kubernetes_sd_configs:
                  - role: node

                  relabel_configs:
                  - action: labelmap
                    regex: __meta_kubernetes_node_label_(.+)
                  - target_label: __address__
                    replacement: kubernetes.default.svc:443
                  - source_labels: [__meta_kubernetes_node_name]
                    regex: (.+)
                    target_label: __metrics_path__
                    replacement: /api/v1/nodes/''${1}/proxy/metrics

                # Scrape config for service endpoints.
                #
                # The relabeling allows the actual service scrape endpoint to be configured
                # via the following annotations:
                #
                # * `prometheus.io/scrape`: Only scrape services that have a value of `true`
                # * `prometheus.io/scheme`: If the metrics endpoint is secured then you will need
                # to set this to `https` & most likely set the `tls_config` of the scrape config.
                # * `prometheus.io/path`: If the metrics path is not `/metrics` override this.
                # * `prometheus.io/port`: If the metrics are exposed on a different port to the
                # service then set this appropriately.
                - job_name: 'kubernetes-service-endpoints'

                  kubernetes_sd_configs:
                  - role: endpoints

                  relabel_configs:
                  - source_labels: [__meta_kubernetes_service_annotation_sourcegraph_prometheus_scrape]
                    action: keep
                    regex: true
                  - source_labels: [__meta_kubernetes_pod_container_name]
                    action: drop
                    regex: jaeger-agent
                  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme]
                    action: replace
                    target_label: __scheme__
                    regex: (https?)
                  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]
                    action: replace
                    target_label: __metrics_path__
                    regex: (.+)
                  - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]
                    action: replace
                    target_label: __address__
                    regex: (.+)(?::\d+);(\d+)
                    replacement: $1:$2
                  - action: labelmap
                    regex: __meta_kubernetes_service_label_(.+)
                  - source_labels: [__meta_kubernetes_namespace]
                    action: replace
                    # Sourcegraph specific customization. We want a more convenient to type label.
                    # target_label: kubernetes_namespace
                    target_label: ns
                  - source_labels: [__meta_kubernetes_service_name]
                    action: replace
                    target_label: kubernetes_name
                  # Sourcegraph specific customization. We want a nicer name for job
                  - source_labels: [app]
                    action: replace
                    target_label: job
                  # Sourcegraph specific customization. We want a nicer name for instance
                  - source_labels: [__meta_kubernetes_pod_name]
                    action: replace
                    target_label: instance

                # Example scrape config for probing services via the Blackbox Exporter.
                #
                # The relabeling allows the actual service scrape endpoint to be configured
                # via the following annotations:
                #
                # * `prometheus.io/probe`: Only probe services that have a value of `true`
                - job_name: 'kubernetes-services'

                  metrics_path: /probe
                  params:
                    module: [http_2xx]

                  kubernetes_sd_configs:
                  - role: service

                  relabel_configs:
                  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe]
                    action: keep
                    regex: true
                  - source_labels: [__address__]
                    target_label: __param_target
                  - target_label: __address__
                    replacement: blackbox
                  - source_labels: [__param_target]
                    target_label: instance
                  - action: labelmap
                    regex: __meta_kubernetes_service_label_(.+)
                  - source_labels: [__meta_kubernetes_service_namespace]
                    # Sourcegraph specific customization. We want a more convenient to type label.
                    # target_label: kubernetes_namespace
                    target_label: ns
                  - source_labels: [__meta_kubernetes_service_name]
                    target_label: kubernetes_name

                # Example scrape config for pods
                #
                # The relabeling allows the actual pod scrape endpoint to be configured via the
                # following annotations:
                #
                # * `prometheus.io/scrape`: Only scrape pods that have a value of `true`
                # * `prometheus.io/path`: If the metrics path is not `/metrics` override this.
                # * `prometheus.io/port`: Scrape the pod on the indicated port instead of the default of `9102`.
                - job_name: 'kubernetes-pods'

                  kubernetes_sd_configs:
                  - role: pod

                  relabel_configs:
                  - source_labels: [__meta_kubernetes_pod_annotation_sourcegraph_prometheus_scrape]
                    action: keep
                    regex: true
                  - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
                    action: replace
                    target_label: __metrics_path__
                    regex: (.+)
                  - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
                    action: replace
                    regex: (.+):(?:\d+);(\d+)
                    replacement: ''${1}:''${2}
                    target_label: __address__
                  - action: labelmap
                    regex: __meta_kubernetes_pod_label_(.+)
                  - source_labels: [__meta_kubernetes_namespace]
                    action: replace
                    # Sourcegraph specific customization. We want a more convenient to type label.
                    # target_label: kubernetes_namespace
                    target_label: ns
                  - source_labels: [__meta_kubernetes_pod_name]
                    action: replace
                    target_label: kubernetes_pod_name

                # Scrape prometheus itself for metrics.
                - job_name: 'builtin-prometheus'
                  static_configs:
                    - targets: ['127.0.0.1:9092']
                      labels:
                        app: prometheus
                - job_name: 'builtin-alertmanager'
                  metrics_path: /alertmanager/metrics
                  static_configs:
                    - targets: ['127.0.0.1:9093']
                      labels:
                        app: alertmanager
                ''
            }
          ]
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "prometheus"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "prometheus"
          }
        }
      , Deployment.prometheus = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Collects metrics and aggregates them into graphs."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "prometheus"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "prometheus"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , minReadySeconds = Some 10
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some [ { mapKey = "app", mapValue = "prometheus" } ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , type = Some "Recreate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "prometheus" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , image = Some
                      "index.docker.io/sourcegraph/prometheus:insiders@sha256:be2484ab1f5b08d6329ad7489d9fbefc8949141de17cec66dfd6bda5a4efd718"
                  , livenessProbe = Some Kubernetes.Probe::{
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/-/healthy"
                      , port = < Int : Natural | String : Text >.Int 9090
                      }
                    , initialDelaySeconds = Some 30
                    , timeoutSeconds = Some 30
                    }
                  , name = "prometheus"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 9090
                      , name = Some "http"
                      }
                    ]
                  , readinessProbe = Some Kubernetes.Probe::{
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/-/ready"
                      , port = < Int : Natural | String : Text >.Int 9090
                      }
                    , initialDelaySeconds = Some 30
                    , timeoutSeconds = Some 30
                    }
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "2" }
                      , { mapKey = "memory", mapValue = "6G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "500m" }
                      , { mapKey = "memory", mapValue = "6G" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/prometheus"
                      , name = "data"
                      }
                    , Kubernetes.VolumeMount::{
                      , mountPath = "/sg_prometheus_add_ons"
                      , name = "config"
                      }
                    ]
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              , serviceAccountName = Some "prometheus"
              , volumes = Some
                [ Kubernetes.Volume::{
                  , name = "data"
                  , persistentVolumeClaim = Some Kubernetes.PersistentVolumeClaimVolumeSource::{
                    , claimName = "prometheus"
                    }
                  }
                , Kubernetes.Volume::{
                  , configMap = Some Kubernetes.ConfigMapVolumeSource::{
                    , defaultMode = Some 511
                    , name = Some "prometheus"
                    }
                  , name = "config"
                  }
                ]
              }
            }
          }
        }
      , PersistentVolumeClaim.prometheus = Kubernetes.PersistentVolumeClaim::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "prometheus"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "prometheus"
          }
        , spec = Some Kubernetes.PersistentVolumeClaimSpec::{
          , accessModes = Some [ "ReadWriteOnce" ]
          , resources = Some Kubernetes.ResourceRequirements::{
            , requests = Some [ { mapKey = "storage", mapValue = "200Gi" } ]
            }
          , storageClassName = Some "sourcegraph"
          }
        }
      , Service.prometheus = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app", mapValue = "prometheus" }
            , { mapKey = "app.kubernetes.io/component"
              , mapValue = "prometheus"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "prometheus"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "http"
              , port = 30090
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "http")
              }
            ]
          , selector = Some [ { mapKey = "app", mapValue = "prometheus" } ]
          , type = Some "ClusterIP"
          }
        }
      , ServiceAccount.prometheus = Kubernetes.ServiceAccount::{
        , imagePullSecrets = Some
          [ Kubernetes.LocalObjectReference::{ name = Some "docker-registry" } ]
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "prometheus"
              }
            , { mapKey = "category", mapValue = "rbac" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "prometheus"
          }
        }
      }
    , Query-Runner =
      { Deployment.query-runner = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Saved search query runner / notification service."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "query-runner"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "query-runner"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , minReadySeconds = Some 10
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some
              [ { mapKey = "app", mapValue = "query-runner" } ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , rollingUpdate = Some Kubernetes.RollingUpdateDeployment::{
              , maxSurge = Some (< Int : Natural | String : Text >.Int 1)
              , maxUnavailable = Some (< Int : Natural | String : Text >.Int 0)
              }
            , type = Some "RollingUpdate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "query-runner" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , image = Some
                      "index.docker.io/sourcegraph/query-runner:insiders@sha256:2c2616819140f3956edc04e1b00ca7b6b70ba05a193966e0f9e31c890fe423e6"
                  , name = "query-runner"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 3183
                      , name = Some "http"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "1G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "500m" }
                      , { mapKey = "memory", mapValue = "1G" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  }
                , Kubernetes.Container::{
                  , args = Some
                    [ "--reporter.grpc.host-port=jaeger-collector:14250"
                    , "--reporter.type=grpc"
                    ]
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "POD_NAME"
                      , valueFrom = Some Kubernetes.EnvVarSource::{
                        , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                          , apiVersion = Some "v1"
                          , fieldPath = "metadata.name"
                          }
                        }
                      }
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/jaeger-agent:insiders@sha256:f3faf496fe750ce75e6304f9ac10d8e1f42c9c9bdab3ab0c2fbf77a8d26084a4"
                  , name = "jaeger-agent"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 5775
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 5778
                      , protocol = Some "TCP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6831
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6832
                      , protocol = Some "UDP"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "500M" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "100m" }
                      , { mapKey = "memory", mapValue = "100M" }
                      ]
                    }
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              }
            }
          }
        }
      , Service.query-runner = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "prometheus.io/port", mapValue = "6060" }
            , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
            ]
          , labels = Some
            [ { mapKey = "app", mapValue = "query-runner" }
            , { mapKey = "app.kubernetes.io/component"
              , mapValue = "query-runner"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "query-runner"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "http"
              , port = 80
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "http")
              }
            ]
          , selector = Some [ { mapKey = "app", mapValue = "query-runner" } ]
          , type = Some "ClusterIP"
          }
        }
      }
    , Redis =
      { Deployment =
        { redis-cache = Kubernetes.Deployment::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "description"
                , mapValue = "Redis for storing short-lived caches."
                }
              ]
            , labels = Some
              [ { mapKey = "app.kubernetes.io/component", mapValue = "redis" }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "redis-cache"
            }
          , spec = Some Kubernetes.DeploymentSpec::{
            , minReadySeconds = Some 10
            , replicas = Some 1
            , revisionHistoryLimit = Some 10
            , selector = Kubernetes.LabelSelector::{
              , matchLabels = Some
                [ { mapKey = "app", mapValue = "redis-cache" } ]
              }
            , strategy = Some Kubernetes.DeploymentStrategy::{
              , type = Some "Recreate"
              }
            , template = Kubernetes.PodTemplateSpec::{
              , metadata = Kubernetes.ObjectMeta::{
                , labels = Some
                  [ { mapKey = "app", mapValue = "redis-cache" }
                  , { mapKey = "deploy", mapValue = "sourcegraph" }
                  ]
                }
              , spec = Some Kubernetes.PodSpec::{
                , containers =
                  [ Kubernetes.Container::{
                    , image = Some
                        "index.docker.io/sourcegraph/redis-cache:insiders@sha256:7820219195ab3e8fdae5875cd690fed1b2a01fd1063bd94210c0e9d529c38e56"
                    , livenessProbe = Some Kubernetes.Probe::{
                      , initialDelaySeconds = Some 30
                      , tcpSocket = Some Kubernetes.TCPSocketAction::{
                        , port =
                            < Int : Natural | String : Text >.String "redis"
                        }
                      }
                    , name = "redis-cache"
                    , ports = Some
                      [ Kubernetes.ContainerPort::{
                        , containerPort = 6379
                        , name = Some "redis"
                        }
                      ]
                    , readinessProbe = Some Kubernetes.Probe::{
                      , initialDelaySeconds = Some 5
                      , tcpSocket = Some Kubernetes.TCPSocketAction::{
                        , port =
                            < Int : Natural | String : Text >.String "redis"
                        }
                      }
                    , resources = Some Kubernetes.ResourceRequirements::{
                      , limits = Some
                        [ { mapKey = "cpu", mapValue = "1" }
                        , { mapKey = "memory", mapValue = "6Gi" }
                        ]
                      , requests = Some
                        [ { mapKey = "cpu", mapValue = "1" }
                        , { mapKey = "memory", mapValue = "6Gi" }
                        ]
                      }
                    , terminationMessagePolicy = Some "FallbackToLogsOnError"
                    , volumeMounts = Some
                      [ Kubernetes.VolumeMount::{
                        , mountPath = "/redis-data"
                        , name = "redis-data"
                        }
                      ]
                    }
                  , Kubernetes.Container::{
                    , image = Some
                        "index.docker.io/sourcegraph/redis_exporter:18-02-07_bb60087_v0.15.0@sha256:282d59b2692cca68da128a4e28d368ced3d17945cd1d273d3ee7ba719d77b753"
                    , name = "redis-exporter"
                    , ports = Some
                      [ Kubernetes.ContainerPort::{
                        , containerPort = 9121
                        , name = Some "redisexp"
                        }
                      ]
                    , resources = Some Kubernetes.ResourceRequirements::{
                      , limits = Some
                        [ { mapKey = "cpu", mapValue = "10m" }
                        , { mapKey = "memory", mapValue = "100Mi" }
                        ]
                      , requests = Some
                        [ { mapKey = "cpu", mapValue = "10m" }
                        , { mapKey = "memory", mapValue = "100Mi" }
                        ]
                      }
                    , terminationMessagePolicy = Some "FallbackToLogsOnError"
                    }
                  ]
                , securityContext = Some Kubernetes.PodSecurityContext::{
                  , runAsUser = Some 0
                  }
                , volumes = Some
                  [ Kubernetes.Volume::{
                    , name = "redis-data"
                    , persistentVolumeClaim = Some Kubernetes.PersistentVolumeClaimVolumeSource::{
                      , claimName = "redis-cache"
                      }
                    }
                  ]
                }
              }
            }
          }
        , redis-store = Kubernetes.Deployment::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "description"
                , mapValue =
                    "Redis for storing semi-persistent data like user sessions."
                }
              ]
            , labels = Some
              [ { mapKey = "app.kubernetes.io/component", mapValue = "redis" }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "redis-store"
            }
          , spec = Some Kubernetes.DeploymentSpec::{
            , minReadySeconds = Some 10
            , replicas = Some 1
            , revisionHistoryLimit = Some 10
            , selector = Kubernetes.LabelSelector::{
              , matchLabels = Some
                [ { mapKey = "app", mapValue = "redis-store" } ]
              }
            , strategy = Some Kubernetes.DeploymentStrategy::{
              , type = Some "Recreate"
              }
            , template = Kubernetes.PodTemplateSpec::{
              , metadata = Kubernetes.ObjectMeta::{
                , labels = Some
                  [ { mapKey = "app", mapValue = "redis-store" }
                  , { mapKey = "deploy", mapValue = "sourcegraph" }
                  ]
                }
              , spec = Some Kubernetes.PodSpec::{
                , containers =
                  [ Kubernetes.Container::{
                    , image = Some
                        "index.docker.io/sourcegraph/redis-store:insiders@sha256:e8467a8279832207559bdfbc4a89b68916ecd5b44ab5cf7620c995461c005168"
                    , livenessProbe = Some Kubernetes.Probe::{
                      , initialDelaySeconds = Some 30
                      , tcpSocket = Some Kubernetes.TCPSocketAction::{
                        , port =
                            < Int : Natural | String : Text >.String "redis"
                        }
                      }
                    , name = "redis-store"
                    , ports = Some
                      [ Kubernetes.ContainerPort::{
                        , containerPort = 6379
                        , name = Some "redis"
                        }
                      ]
                    , readinessProbe = Some Kubernetes.Probe::{
                      , initialDelaySeconds = Some 5
                      , tcpSocket = Some Kubernetes.TCPSocketAction::{
                        , port =
                            < Int : Natural | String : Text >.String "redis"
                        }
                      }
                    , resources = Some Kubernetes.ResourceRequirements::{
                      , limits = Some
                        [ { mapKey = "cpu", mapValue = "1" }
                        , { mapKey = "memory", mapValue = "6Gi" }
                        ]
                      , requests = Some
                        [ { mapKey = "cpu", mapValue = "1" }
                        , { mapKey = "memory", mapValue = "6Gi" }
                        ]
                      }
                    , terminationMessagePolicy = Some "FallbackToLogsOnError"
                    , volumeMounts = Some
                      [ Kubernetes.VolumeMount::{
                        , mountPath = "/redis-data"
                        , name = "redis-data"
                        }
                      ]
                    }
                  , Kubernetes.Container::{
                    , image = Some
                        "index.docker.io/sourcegraph/redis_exporter:18-02-07_bb60087_v0.15.0@sha256:282d59b2692cca68da128a4e28d368ced3d17945cd1d273d3ee7ba719d77b753"
                    , name = "redis-exporter"
                    , ports = Some
                      [ Kubernetes.ContainerPort::{
                        , containerPort = 9121
                        , name = Some "redisexp"
                        }
                      ]
                    , resources = Some Kubernetes.ResourceRequirements::{
                      , limits = Some
                        [ { mapKey = "cpu", mapValue = "10m" }
                        , { mapKey = "memory", mapValue = "100Mi" }
                        ]
                      , requests = Some
                        [ { mapKey = "cpu", mapValue = "10m" }
                        , { mapKey = "memory", mapValue = "100Mi" }
                        ]
                      }
                    , terminationMessagePolicy = Some "FallbackToLogsOnError"
                    }
                  ]
                , securityContext = Some Kubernetes.PodSecurityContext::{
                  , runAsUser = Some 0
                  }
                , volumes = Some
                  [ Kubernetes.Volume::{
                    , name = "redis-data"
                    , persistentVolumeClaim = Some Kubernetes.PersistentVolumeClaimVolumeSource::{
                      , claimName = "redis-store"
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      , PersistentVolumeClaim =
        { redis-cache = Kubernetes.PersistentVolumeClaim::{
          , metadata = Kubernetes.ObjectMeta::{
            , labels = Some
              [ { mapKey = "app.kubernetes.io/component", mapValue = "redis" }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "redis-cache"
            }
          , spec = Some Kubernetes.PersistentVolumeClaimSpec::{
            , accessModes = Some [ "ReadWriteOnce" ]
            , resources = Some Kubernetes.ResourceRequirements::{
              , requests = Some [ { mapKey = "storage", mapValue = "100Gi" } ]
              }
            , storageClassName = Some "sourcegraph"
            }
          }
        , redis-store = Kubernetes.PersistentVolumeClaim::{
          , metadata = Kubernetes.ObjectMeta::{
            , labels = Some
              [ { mapKey = "app.kubernetes.io/component", mapValue = "redis" }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "redis-store"
            }
          , spec = Some Kubernetes.PersistentVolumeClaimSpec::{
            , accessModes = Some [ "ReadWriteOnce" ]
            , resources = Some Kubernetes.ResourceRequirements::{
              , requests = Some [ { mapKey = "storage", mapValue = "100Gi" } ]
              }
            , storageClassName = Some "sourcegraph"
            }
          }
        }
      , Service =
        { redis-cache = Kubernetes.Service::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "prometheus.io/port", mapValue = "9121" }
              , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
              ]
            , labels = Some
              [ { mapKey = "app", mapValue = "redis-cache" }
              , { mapKey = "app.kubernetes.io/component", mapValue = "redis" }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "redis-cache"
            }
          , spec = Some Kubernetes.ServiceSpec::{
            , ports = Some
              [ Kubernetes.ServicePort::{
                , name = Some "redis"
                , port = 6379
                , targetPort = Some
                    (< Int : Natural | String : Text >.String "redis")
                }
              ]
            , selector = Some [ { mapKey = "app", mapValue = "redis-cache" } ]
            , type = Some "ClusterIP"
            }
          }
        , redis-store = Kubernetes.Service::{
          , metadata = Kubernetes.ObjectMeta::{
            , annotations = Some
              [ { mapKey = "prometheus.io/port", mapValue = "9121" }
              , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
              ]
            , labels = Some
              [ { mapKey = "app", mapValue = "redis-store" }
              , { mapKey = "app.kubernetes.io/component", mapValue = "redis" }
              , { mapKey = "deploy", mapValue = "sourcegraph" }
              , { mapKey = "sourcegraph-resource-requires"
                , mapValue = "no-cluster-admin"
                }
              ]
            , name = Some "redis-store"
            }
          , spec = Some Kubernetes.ServiceSpec::{
            , ports = Some
              [ Kubernetes.ServicePort::{
                , name = Some "redis"
                , port = 6379
                , targetPort = Some
                    (< Int : Natural | String : Text >.String "redis")
                }
              ]
            , selector = Some [ { mapKey = "app", mapValue = "redis-store" } ]
            , type = Some "ClusterIP"
            }
          }
        }
      }
    , Repo-Updater =
      { Deployment.repo-updater = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue =
                  "Handles repository metadata (not Git data) lookups and updates from external code hosts and other similar services."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "repo-updater"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "repo-updater"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , minReadySeconds = Some 10
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some
              [ { mapKey = "app", mapValue = "repo-updater" } ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , rollingUpdate = Some Kubernetes.RollingUpdateDeployment::{
              , maxSurge = Some (< Int : Natural | String : Text >.Int 1)
              , maxUnavailable = Some (< Int : Natural | String : Text >.Int 0)
              }
            , type = Some "RollingUpdate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "repo-updater" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , image = Some
                      "index.docker.io/sourcegraph/repo-updater:insiders@sha256:ed2460d032ab2b025f68cf127ddf39fb17dbb53c83f718c142de66d51ecd575d"
                  , name = "repo-updater"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 3182
                      , name = Some "http"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6060
                      , name = Some "debug"
                      }
                    ]
                  , readinessProbe = Some Kubernetes.Probe::{
                    , failureThreshold = Some 3
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/healthz"
                      , port = < Int : Natural | String : Text >.String "http"
                      , scheme = Some "HTTP"
                      }
                    , periodSeconds = Some 1
                    , timeoutSeconds = Some 5
                    }
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "2Gi" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "500Mi" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  }
                , Kubernetes.Container::{
                  , args = Some
                    [ "--reporter.grpc.host-port=jaeger-collector:14250"
                    , "--reporter.type=grpc"
                    ]
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "POD_NAME"
                      , valueFrom = Some Kubernetes.EnvVarSource::{
                        , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                          , apiVersion = Some "v1"
                          , fieldPath = "metadata.name"
                          }
                        }
                      }
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/jaeger-agent:insiders@sha256:f3faf496fe750ce75e6304f9ac10d8e1f42c9c9bdab3ab0c2fbf77a8d26084a4"
                  , name = "jaeger-agent"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 5775
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 5778
                      , protocol = Some "TCP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6831
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6832
                      , protocol = Some "UDP"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "500M" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "100m" }
                      , { mapKey = "memory", mapValue = "100M" }
                      ]
                    }
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              }
            }
          }
        }
      , Service.repo-updater = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "prometheus.io/port", mapValue = "6060" }
            , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
            ]
          , labels = Some
            [ { mapKey = "app", mapValue = "repo-updater" }
            , { mapKey = "app.kubernetes.io/component"
              , mapValue = "repo-updater"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "repo-updater"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "http"
              , port = 3182
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "http")
              }
            ]
          , selector = Some [ { mapKey = "app", mapValue = "repo-updater" } ]
          , type = Some "ClusterIP"
          }
        }
      }
    , Searcher =
      { Deployment.searcher = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Backend for text search operations."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "searcher" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "searcher"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , minReadySeconds = Some 10
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some [ { mapKey = "app", mapValue = "searcher" } ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , rollingUpdate = Some Kubernetes.RollingUpdateDeployment::{
              , maxSurge = Some (< Int : Natural | String : Text >.Int 1)
              , maxUnavailable = Some (< Int : Natural | String : Text >.Int 1)
              }
            , type = Some "RollingUpdate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "searcher" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "SEARCHER_CACHE_SIZE_MB"
                      , value = Some "100000"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "POD_NAME"
                      , valueFrom = Some Kubernetes.EnvVarSource::{
                        , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                          , fieldPath = "metadata.name"
                          }
                        }
                      }
                    , Kubernetes.EnvVar::{
                      , name = "CACHE_DIR"
                      , value = Some "/mnt/cache/\$(POD_NAME)"
                      }
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/searcher:insiders@sha256:83067d2a03d5de115497c01f95a09a09d208c4ba60b6fc7adfb6270a104ce397"
                  , name = "searcher"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 3181
                      , name = Some "http"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6060
                      , name = Some "debug"
                      }
                    ]
                  , readinessProbe = Some Kubernetes.Probe::{
                    , failureThreshold = Some 3
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/healthz"
                      , port = < Int : Natural | String : Text >.String "http"
                      , scheme = Some "HTTP"
                      }
                    , periodSeconds = Some 5
                    , timeoutSeconds = Some 5
                    }
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "2" }
                      , { mapKey = "memory", mapValue = "2G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "500m" }
                      , { mapKey = "memory", mapValue = "500M" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/mnt/cache"
                      , name = "cache-ssd"
                      }
                    ]
                  }
                , Kubernetes.Container::{
                  , args = Some
                    [ "--reporter.grpc.host-port=jaeger-collector:14250"
                    , "--reporter.type=grpc"
                    ]
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "POD_NAME"
                      , valueFrom = Some Kubernetes.EnvVarSource::{
                        , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                          , apiVersion = Some "v1"
                          , fieldPath = "metadata.name"
                          }
                        }
                      }
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/jaeger-agent:insiders@sha256:f3faf496fe750ce75e6304f9ac10d8e1f42c9c9bdab3ab0c2fbf77a8d26084a4"
                  , name = "jaeger-agent"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 5775
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 5778
                      , protocol = Some "TCP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6831
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6832
                      , protocol = Some "UDP"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "500M" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "100m" }
                      , { mapKey = "memory", mapValue = "100M" }
                      ]
                    }
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              , volumes = Some
                [ Kubernetes.Volume::{
                  , emptyDir = Some Kubernetes.EmptyDirVolumeSource::{=}
                  , name = "cache-ssd"
                  }
                ]
              }
            }
          }
        }
      , Service.searcher = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "prometheus.io/port", mapValue = "6060" }
            , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
            ]
          , labels = Some
            [ { mapKey = "app", mapValue = "searcher" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "searcher" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "searcher"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "http"
              , port = 3181
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "http")
              }
            , Kubernetes.ServicePort::{
              , name = Some "debug"
              , port = 6060
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "debug")
              }
            ]
          , selector = Some [ { mapKey = "app", mapValue = "searcher" } ]
          , type = Some "ClusterIP"
          }
        }
      }
    , Symbols =
      { Deployment.symbols = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Backend for symbols operations."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component", mapValue = "symbols" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "symbols"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , minReadySeconds = Some 10
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some [ { mapKey = "app", mapValue = "symbols" } ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , rollingUpdate = Some Kubernetes.RollingUpdateDeployment::{
              , maxSurge = Some (< Int : Natural | String : Text >.Int 1)
              , maxUnavailable = Some (< Int : Natural | String : Text >.Int 1)
              }
            , type = Some "RollingUpdate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "symbols" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "SYMBOLS_CACHE_SIZE_MB"
                      , value = Some "100000"
                      }
                    , Kubernetes.EnvVar::{
                      , name = "POD_NAME"
                      , valueFrom = Some Kubernetes.EnvVarSource::{
                        , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                          , fieldPath = "metadata.name"
                          }
                        }
                      }
                    , Kubernetes.EnvVar::{
                      , name = "CACHE_DIR"
                      , value = Some "/mnt/cache/\$(POD_NAME)"
                      }
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/symbols:insiders@sha256:cbfae2f0c766fdcf0aad7c6c72a7ad3bd2f2326fcb93fb95feda6eed139d22f6"
                  , livenessProbe = Some Kubernetes.Probe::{
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/healthz"
                      , port = < Int : Natural | String : Text >.String "http"
                      , scheme = Some "HTTP"
                      }
                    , initialDelaySeconds = Some 60
                    , timeoutSeconds = Some 5
                    }
                  , name = "symbols"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 3184
                      , name = Some "http"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6060
                      , name = Some "debug"
                      }
                    ]
                  , readinessProbe = Some Kubernetes.Probe::{
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/healthz"
                      , port = < Int : Natural | String : Text >.String "http"
                      , scheme = Some "HTTP"
                      }
                    , periodSeconds = Some 5
                    , timeoutSeconds = Some 5
                    }
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "2" }
                      , { mapKey = "memory", mapValue = "2G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "500m" }
                      , { mapKey = "memory", mapValue = "500M" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  , volumeMounts = Some
                    [ Kubernetes.VolumeMount::{
                      , mountPath = "/mnt/cache"
                      , name = "cache-ssd"
                      }
                    ]
                  }
                , Kubernetes.Container::{
                  , args = Some
                    [ "--reporter.grpc.host-port=jaeger-collector:14250"
                    , "--reporter.type=grpc"
                    ]
                  , env = Some
                    [ Kubernetes.EnvVar::{
                      , name = "POD_NAME"
                      , valueFrom = Some Kubernetes.EnvVarSource::{
                        , fieldRef = Some Kubernetes.ObjectFieldSelector::{
                          , apiVersion = Some "v1"
                          , fieldPath = "metadata.name"
                          }
                        }
                      }
                    ]
                  , image = Some
                      "index.docker.io/sourcegraph/jaeger-agent:insiders@sha256:f3faf496fe750ce75e6304f9ac10d8e1f42c9c9bdab3ab0c2fbf77a8d26084a4"
                  , name = "jaeger-agent"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 5775
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 5778
                      , protocol = Some "TCP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6831
                      , protocol = Some "UDP"
                      }
                    , Kubernetes.ContainerPort::{
                      , containerPort = 6832
                      , protocol = Some "UDP"
                      }
                    ]
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "1" }
                      , { mapKey = "memory", mapValue = "500M" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "100m" }
                      , { mapKey = "memory", mapValue = "100M" }
                      ]
                    }
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              , volumes = Some
                [ Kubernetes.Volume::{
                  , emptyDir = Some Kubernetes.EmptyDirVolumeSource::{=}
                  , name = "cache-ssd"
                  }
                ]
              }
            }
          }
        }
      , Service.symbols = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "prometheus.io/port", mapValue = "6060" }
            , { mapKey = "sourcegraph.prometheus/scrape", mapValue = "true" }
            ]
          , labels = Some
            [ { mapKey = "app", mapValue = "symbols" }
            , { mapKey = "app.kubernetes.io/component", mapValue = "symbols" }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "symbols"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "http"
              , port = 3184
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "http")
              }
            , Kubernetes.ServicePort::{
              , name = Some "debug"
              , port = 6060
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "debug")
              }
            ]
          , selector = Some [ { mapKey = "app", mapValue = "symbols" } ]
          , type = Some "ClusterIP"
          }
        }
      }
    , Syntect-Server =
      { Deployment.syntect-server = Kubernetes.Deployment::{
        , metadata = Kubernetes.ObjectMeta::{
          , annotations = Some
            [ { mapKey = "description"
              , mapValue = "Backend for syntax highlighting operations."
              }
            ]
          , labels = Some
            [ { mapKey = "app.kubernetes.io/component"
              , mapValue = "syntect-server"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "syntect-server"
          }
        , spec = Some Kubernetes.DeploymentSpec::{
          , minReadySeconds = Some 10
          , replicas = Some 1
          , revisionHistoryLimit = Some 10
          , selector = Kubernetes.LabelSelector::{
            , matchLabels = Some
              [ { mapKey = "app", mapValue = "syntect-server" } ]
            }
          , strategy = Some Kubernetes.DeploymentStrategy::{
            , rollingUpdate = Some Kubernetes.RollingUpdateDeployment::{
              , maxSurge = Some (< Int : Natural | String : Text >.Int 1)
              , maxUnavailable = Some (< Int : Natural | String : Text >.Int 0)
              }
            , type = Some "RollingUpdate"
            }
          , template = Kubernetes.PodTemplateSpec::{
            , metadata = Kubernetes.ObjectMeta::{
              , labels = Some
                [ { mapKey = "app", mapValue = "syntect-server" }
                , { mapKey = "deploy", mapValue = "sourcegraph" }
                ]
              }
            , spec = Some Kubernetes.PodSpec::{
              , containers =
                [ Kubernetes.Container::{
                  , image = Some
                      "index.docker.io/sourcegraph/syntax-highlighter:insiders@sha256:b9e1f7471ebe596415ca2c7ab8e1282d7c4ba4e4e71390d80e9924a73139d793"
                  , livenessProbe = Some Kubernetes.Probe::{
                    , httpGet = Some Kubernetes.HTTPGetAction::{
                      , path = Some "/health"
                      , port = < Int : Natural | String : Text >.String "http"
                      , scheme = Some "HTTP"
                      }
                    , initialDelaySeconds = Some 5
                    , timeoutSeconds = Some 5
                    }
                  , name = "syntect-server"
                  , ports = Some
                    [ Kubernetes.ContainerPort::{
                      , containerPort = 9238
                      , name = Some "http"
                      }
                    ]
                  , readinessProbe = Some Kubernetes.Probe::{
                    , tcpSocket = Some Kubernetes.TCPSocketAction::{
                      , port = < Int : Natural | String : Text >.String "http"
                      }
                    }
                  , resources = Some Kubernetes.ResourceRequirements::{
                    , limits = Some
                      [ { mapKey = "cpu", mapValue = "4" }
                      , { mapKey = "memory", mapValue = "6G" }
                      ]
                    , requests = Some
                      [ { mapKey = "cpu", mapValue = "250m" }
                      , { mapKey = "memory", mapValue = "2G" }
                      ]
                    }
                  , terminationMessagePolicy = Some "FallbackToLogsOnError"
                  }
                ]
              , securityContext = Some Kubernetes.PodSecurityContext::{
                , runAsUser = Some 0
                }
              }
            }
          }
        }
      , Service.syntect-server = Kubernetes.Service::{
        , metadata = Kubernetes.ObjectMeta::{
          , labels = Some
            [ { mapKey = "app", mapValue = "syntect-server" }
            , { mapKey = "app.kubernetes.io/component"
              , mapValue = "syntect-server"
              }
            , { mapKey = "deploy", mapValue = "sourcegraph" }
            , { mapKey = "sourcegraph-resource-requires"
              , mapValue = "no-cluster-admin"
              }
            ]
          , name = Some "syntect-server"
          }
        , spec = Some Kubernetes.ServiceSpec::{
          , ports = Some
            [ Kubernetes.ServicePort::{
              , name = Some "http"
              , port = 9238
              , targetPort = Some
                  (< Int : Natural | String : Text >.String "http")
              }
            ]
          , selector = Some [ { mapKey = "app", mapValue = "syntect-server" } ]
          , type = Some "ClusterIP"
          }
        }
      }
    }
